export var AddressMode: any;
export class AlphaState {
    _blendFunctionParameters: any[];
    _blendEquationParameters: any[];
    _blendConstants: any[];
    _isBlendConstantsDirty: boolean;
    _alphaBlend: boolean;
    _isAlphaBlendDirty: boolean;
    _isBlendFunctionParametersDirty: boolean;
    _isBlendEquationParametersDirty: boolean;
    get isDirty(): boolean;
    set alphaBlend(arg: boolean);
    get alphaBlend(): boolean;
    setAlphaBlendConstants(r: any, g: any, b: any, a: any): void;
    setAlphaBlendFunctionParameters(value0: any, value1: any, value2: any, value3: any): void;
    setAlphaEquationParameters(rgb: any, alpha: any): void;
    reset(): void;
    apply(gl: any): void;
}
export var BlendFactor: any;
export var BlendOperation: any;
export class Buffer {
    constructor(engine: any, data: any, updatable: any, stride: number, postponeInternalCreation: boolean, instanced: boolean, useBytes: boolean, divisor: any);
    _isAlreadyOwned: boolean;
    _engine: any;
    _updatable: any;
    _instanced: boolean;
    _divisor: any;
    _data: any;
    _buffer: DataBuffer;
    byteStride: number;
    createVertexBuffer(kind: any, offset: any, size: any, stride: any, instanced: any, useBytes: boolean, divisor: any): VertexBuffer;
    isUpdatable(): any;
    getData(): any;
    getBuffer(): DataBuffer;
    getStrideSize(): number;
    create(data?: any): void;
    _rebuild(): void;
    update(data: any): void;
    updateDirectly(data: any, offset: any, vertexCount: any, useBytes?: boolean): void;
    _increaseReferences(): void;
    dispose(): void;
}
export var BufferBindingType: any;
export var BufferUsage: any;
export var CanvasCompositingAlphaMode: any;
export class Color3 {
    static HSVtoRGBToRef(hue: any, saturation: any, value: any, result: any): void;
    static FromHexString(hex: any): Color3;
    static FromArray(array: any, offset?: number): Color3;
    static FromArrayToRef(array: any, offset: number, result: any): void;
    static FromInts(r: any, g: any, b: any): Color3;
    static Lerp(start: any, end: any, amount: any): Color3;
    static LerpToRef(left: any, right: any, amount: any, result: any): void;
    static Hermite(value1: any, tangent1: any, value2: any, tangent2: any, amount: any): Color3;
    static Hermite1stDerivative(value1: any, tangent1: any, value2: any, tangent2: any, time: any): Color3;
    static Hermite1stDerivativeToRef(value1: any, tangent1: any, value2: any, tangent2: any, time: any, result: any): void;
    static Red(): Color3;
    static Green(): Color3;
    static Blue(): Color3;
    static Black(): Color3;
    static get BlackReadOnly(): Color3;
    static White(): Color3;
    static Purple(): Color3;
    static Magenta(): Color3;
    static Yellow(): Color3;
    static Gray(): Color3;
    static Teal(): Color3;
    static Random(): Color3;
    constructor(r?: number, g?: number, b?: number);
    r: number;
    g: number;
    b: number;
    toString(): string;
    getClassName(): string;
    getHashCode(): number;
    toArray(array: any, index?: number): Color3;
    fromArray(array: any, offset?: number): Color3;
    toColor4(alpha?: number): Color4;
    asArray(): any[];
    toLuminance(): number;
    multiply(otherColor: any): Color3;
    multiplyToRef(otherColor: any, result: any): Color3;
    equals(otherColor: any): boolean;
    equalsFloats(r: any, g: any, b: any): boolean;
    scale(scale: any): Color3;
    scaleToRef(scale: any, result: any): Color3;
    scaleAndAddToRef(scale: any, result: any): Color3;
    clampToRef(min: number, max: number, result: any): Color3;
    add(otherColor: any): Color3;
    addToRef(otherColor: any, result: any): Color3;
    subtract(otherColor: any): Color3;
    subtractToRef(otherColor: any, result: any): Color3;
    clone(): Color3;
    copyFrom(source: any): Color3;
    copyFromFloats(r: any, g: any, b: any): Color3;
    set(r: any, g: any, b: any): Color3;
    toHexString(): string;
    toLinearSpace(): Color3;
    toHSV(): Color3;
    toHSVToRef(result: any): void;
    toLinearSpaceToRef(convertedColor: any): Color3;
    toGammaSpace(): Color3;
    toGammaSpaceToRef(convertedColor: any): Color3;
}
export namespace Color3 {
    const _BlackReadOnly: Color3;
}
export class Color4 {
    static FromHexString(hex: any): Color4;
    static Lerp(left: any, right: any, amount: any): Color4;
    static LerpToRef(left: any, right: any, amount: any, result: any): void;
    static Hermite(value1: any, tangent1: any, value2: any, tangent2: any, amount: any): Color4;
    static Hermite1stDerivative(value1: any, tangent1: any, value2: any, tangent2: any, time: any): Color4;
    static Hermite1stDerivativeToRef(value1: any, tangent1: any, value2: any, tangent2: any, time: any, result: any): void;
    static FromColor3(color3: any, alpha?: number): Color4;
    static FromArray(array: any, offset?: number): Color4;
    static FromArrayToRef(array: any, offset: number, result: any): void;
    static FromInts(r: any, g: any, b: any, a: any): Color4;
    static CheckColors4(colors: any, count: any): any;
    constructor(r?: number, g?: number, b?: number, a?: number);
    r: number;
    g: number;
    b: number;
    a: number;
    addInPlace(right: any): Color4;
    asArray(): any[];
    toArray(array: any, index?: number): Color4;
    fromArray(array: any, offset?: number): Color4;
    equals(otherColor: any): boolean;
    add(right: any): Color4;
    subtract(right: any): Color4;
    subtractToRef(right: any, result: any): Color4;
    scale(scale: any): Color4;
    scaleToRef(scale: any, result: any): Color4;
    scaleAndAddToRef(scale: any, result: any): Color4;
    clampToRef(min: number, max: number, result: any): Color4;
    multiply(color: any): Color4;
    multiplyToRef(color: any, result: any): any;
    toString(): string;
    getClassName(): string;
    getHashCode(): number;
    clone(): Color4;
    copyFrom(source: any): Color4;
    copyFromFloats(r: any, g: any, b: any, a: any): Color4;
    set(r: any, g: any, b: any, a: any): Color4;
    toHexString(returnAsColor3?: boolean): string;
    toLinearSpace(): Color4;
    toLinearSpaceToRef(convertedColor: any): Color4;
    toGammaSpace(): Color4;
    toGammaSpaceToRef(convertedColor: any): Color4;
}
export var ColorWrite: any;
export var CompareFunction: any;
export var CompilationMessageType: any;
export var ComputePassTimestampLocation: any;
export class Constants {
}
export namespace Constants {
    const ALPHA_DISABLE: number;
    const ALPHA_ADD: number;
    const ALPHA_COMBINE: number;
    const ALPHA_SUBTRACT: number;
    const ALPHA_MULTIPLY: number;
    const ALPHA_MAXIMIZED: number;
    const ALPHA_ONEONE: number;
    const ALPHA_PREMULTIPLIED: number;
    const ALPHA_PREMULTIPLIED_PORTERDUFF: number;
    const ALPHA_INTERPOLATE: number;
    const ALPHA_SCREENMODE: number;
    const ALPHA_ONEONE_ONEONE: number;
    const ALPHA_ALPHATOCOLOR: number;
    const ALPHA_REVERSEONEMINUS: number;
    const ALPHA_SRC_DSTONEMINUSSRCALPHA: number;
    const ALPHA_ONEONE_ONEZERO: number;
    const ALPHA_EXCLUSION: number;
    const ALPHA_LAYER_ACCUMULATE: number;
    const ALPHA_EQUATION_ADD: number;
    const ALPHA_EQUATION_SUBSTRACT: number;
    const ALPHA_EQUATION_REVERSE_SUBTRACT: number;
    const ALPHA_EQUATION_MAX: number;
    const ALPHA_EQUATION_MIN: number;
    const ALPHA_EQUATION_DARKEN: number;
    const DELAYLOADSTATE_NONE: number;
    const DELAYLOADSTATE_LOADED: number;
    const DELAYLOADSTATE_LOADING: number;
    const DELAYLOADSTATE_NOTLOADED: number;
    const NEVER: number;
    const ALWAYS: number;
    const LESS: number;
    const EQUAL: number;
    const LEQUAL: number;
    const GREATER: number;
    const GEQUAL: number;
    const NOTEQUAL: number;
    const KEEP: number;
    const ZERO: number;
    const REPLACE: number;
    const INCR: number;
    const DECR: number;
    const INVERT: number;
    const INCR_WRAP: number;
    const DECR_WRAP: number;
    const TEXTURE_CLAMP_ADDRESSMODE: number;
    const TEXTURE_WRAP_ADDRESSMODE: number;
    const TEXTURE_MIRROR_ADDRESSMODE: number;
    const TEXTURE_CREATIONFLAG_STORAGE: number;
    const TEXTUREFORMAT_ALPHA: number;
    const TEXTUREFORMAT_LUMINANCE: number;
    const TEXTUREFORMAT_LUMINANCE_ALPHA: number;
    const TEXTUREFORMAT_RGB: number;
    const TEXTUREFORMAT_RGBA: number;
    const TEXTUREFORMAT_RED: number;
    const TEXTUREFORMAT_R: number;
    const TEXTUREFORMAT_RG: number;
    const TEXTUREFORMAT_RED_INTEGER: number;
    const TEXTUREFORMAT_R_INTEGER: number;
    const TEXTUREFORMAT_RG_INTEGER: number;
    const TEXTUREFORMAT_RGB_INTEGER: number;
    const TEXTUREFORMAT_RGBA_INTEGER: number;
    const TEXTUREFORMAT_BGRA: number;
    const TEXTUREFORMAT_DEPTH24_STENCIL8: number;
    const TEXTUREFORMAT_DEPTH32_FLOAT: number;
    const TEXTUREFORMAT_DEPTH16: number;
    const TEXTUREFORMAT_DEPTH24: number;
    const TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM: number;
    const TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: number;
    const TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: number;
    const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5: number;
    const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3: number;
    const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1: number;
    const TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1: number;
    const TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4: number;
    const TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL: number;
    const TEXTURETYPE_UNSIGNED_BYTE: number;
    const TEXTURETYPE_UNSIGNED_INT: number;
    const TEXTURETYPE_FLOAT: number;
    const TEXTURETYPE_HALF_FLOAT: number;
    const TEXTURETYPE_BYTE: number;
    const TEXTURETYPE_SHORT: number;
    const TEXTURETYPE_UNSIGNED_SHORT: number;
    const TEXTURETYPE_INT: number;
    const TEXTURETYPE_UNSIGNED_INTEGER: number;
    const TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4: number;
    const TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1: number;
    const TEXTURETYPE_UNSIGNED_SHORT_5_6_5: number;
    const TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV: number;
    const TEXTURETYPE_UNSIGNED_INT_24_8: number;
    const TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV: number;
    const TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV: number;
    const TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV: number;
    const TEXTURETYPE_UNDEFINED: number;
    const TEXTURE_NEAREST_SAMPLINGMODE: number;
    const TEXTURE_NEAREST_NEAREST: number;
    const TEXTURE_BILINEAR_SAMPLINGMODE: number;
    const TEXTURE_LINEAR_LINEAR: number;
    const TEXTURE_TRILINEAR_SAMPLINGMODE: number;
    const TEXTURE_LINEAR_LINEAR_MIPLINEAR: number;
    const TEXTURE_NEAREST_NEAREST_MIPNEAREST: number;
    const TEXTURE_NEAREST_LINEAR_MIPNEAREST: number;
    const TEXTURE_NEAREST_LINEAR_MIPLINEAR: number;
    const TEXTURE_NEAREST_LINEAR: number;
    const TEXTURE_NEAREST_NEAREST_MIPLINEAR: number;
    const TEXTURE_LINEAR_NEAREST_MIPNEAREST: number;
    const TEXTURE_LINEAR_NEAREST_MIPLINEAR: number;
    const TEXTURE_LINEAR_LINEAR_MIPNEAREST: number;
    const TEXTURE_LINEAR_NEAREST: number;
    const TEXTURE_EXPLICIT_MODE: number;
    const TEXTURE_SPHERICAL_MODE: number;
    const TEXTURE_PLANAR_MODE: number;
    const TEXTURE_CUBIC_MODE: number;
    const TEXTURE_PROJECTION_MODE: number;
    const TEXTURE_SKYBOX_MODE: number;
    const TEXTURE_INVCUBIC_MODE: number;
    const TEXTURE_EQUIRECTANGULAR_MODE: number;
    const TEXTURE_FIXED_EQUIRECTANGULAR_MODE: number;
    const TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE: number;
    const TEXTURE_FILTERING_QUALITY_OFFLINE: number;
    const TEXTURE_FILTERING_QUALITY_HIGH: number;
    const TEXTURE_FILTERING_QUALITY_MEDIUM: number;
    const TEXTURE_FILTERING_QUALITY_LOW: number;
    const SCALEMODE_FLOOR: number;
    const SCALEMODE_NEAREST: number;
    const SCALEMODE_CEILING: number;
    const MATERIAL_TextureDirtyFlag: number;
    const MATERIAL_LightDirtyFlag: number;
    const MATERIAL_FresnelDirtyFlag: number;
    const MATERIAL_AttributesDirtyFlag: number;
    const MATERIAL_MiscDirtyFlag: number;
    const MATERIAL_PrePassDirtyFlag: number;
    const MATERIAL_AllDirtyFlag: number;
    const MATERIAL_TriangleFillMode: number;
    const MATERIAL_WireFrameFillMode: number;
    const MATERIAL_PointFillMode: number;
    const MATERIAL_PointListDrawMode: number;
    const MATERIAL_LineListDrawMode: number;
    const MATERIAL_LineLoopDrawMode: number;
    const MATERIAL_LineStripDrawMode: number;
    const MATERIAL_TriangleStripDrawMode: number;
    const MATERIAL_TriangleFanDrawMode: number;
    const MATERIAL_ClockWiseSideOrientation: number;
    const MATERIAL_CounterClockWiseSideOrientation: number;
    const ACTION_NothingTrigger: number;
    const ACTION_OnPickTrigger: number;
    const ACTION_OnLeftPickTrigger: number;
    const ACTION_OnRightPickTrigger: number;
    const ACTION_OnCenterPickTrigger: number;
    const ACTION_OnPickDownTrigger: number;
    const ACTION_OnDoublePickTrigger: number;
    const ACTION_OnPickUpTrigger: number;
    const ACTION_OnPickOutTrigger: number;
    const ACTION_OnLongPressTrigger: number;
    const ACTION_OnPointerOverTrigger: number;
    const ACTION_OnPointerOutTrigger: number;
    const ACTION_OnEveryFrameTrigger: number;
    const ACTION_OnIntersectionEnterTrigger: number;
    const ACTION_OnIntersectionExitTrigger: number;
    const ACTION_OnKeyDownTrigger: number;
    const ACTION_OnKeyUpTrigger: number;
    const PARTICLES_BILLBOARDMODE_Y: number;
    const PARTICLES_BILLBOARDMODE_ALL: number;
    const PARTICLES_BILLBOARDMODE_STRETCHED: number;
    const MESHES_CULLINGSTRATEGY_STANDARD: number;
    const MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: number;
    const MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION: number;
    const MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY: number;
    const SCENELOADER_NO_LOGGING: number;
    const SCENELOADER_MINIMAL_LOGGING: number;
    const SCENELOADER_SUMMARY_LOGGING: number;
    const SCENELOADER_DETAILED_LOGGING: number;
    const PREPASS_IRRADIANCE_TEXTURE_TYPE: number;
    const PREPASS_POSITION_TEXTURE_TYPE: number;
    const PREPASS_VELOCITY_TEXTURE_TYPE: number;
    const PREPASS_REFLECTIVITY_TEXTURE_TYPE: number;
    const PREPASS_COLOR_TEXTURE_TYPE: number;
    const PREPASS_DEPTH_TEXTURE_TYPE: number;
    const PREPASS_NORMAL_TEXTURE_TYPE: number;
    const PREPASS_ALBEDO_SQRT_TEXTURE_TYPE: number;
    const BUFFER_CREATIONFLAG_READ: number;
    const BUFFER_CREATIONFLAG_WRITE: number;
    const BUFFER_CREATIONFLAG_READWRITE: number;
    const BUFFER_CREATIONFLAG_UNIFORM: number;
    const BUFFER_CREATIONFLAG_VERTEX: number;
    const BUFFER_CREATIONFLAG_INDEX: number;
    const BUFFER_CREATIONFLAG_STORAGE: number;
    const RENDERPASS_MAIN: number;
    const INPUT_ALT_KEY: number;
    const INPUT_CTRL_KEY: number;
    const INPUT_META_KEY1: number;
    const INPUT_META_KEY2: number;
    const INPUT_META_KEY3: number;
    const INPUT_SHIFT_KEY: number;
    const SNAPSHOTRENDERING_STANDARD: number;
    const SNAPSHOTRENDERING_FAST: number;
    const PERSPECTIVE_CAMERA: number;
    const ORTHOGRAPHIC_CAMERA: number;
    const FOVMODE_VERTICAL_FIXED: number;
    const FOVMODE_HORIZONTAL_FIXED: number;
    const RIG_MODE_NONE: number;
    const RIG_MODE_STEREOSCOPIC_ANAGLYPH: number;
    const RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: number;
    const RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: number;
    const RIG_MODE_STEREOSCOPIC_OVERUNDER: number;
    const RIG_MODE_STEREOSCOPIC_INTERLACED: number;
    const RIG_MODE_VR: number;
    const RIG_MODE_WEBVR: number;
    const RIG_MODE_CUSTOM: number;
    const MAX_SUPPORTED_UV_SETS: number;
    const GL_ALPHA_EQUATION_ADD: number;
    const GL_ALPHA_EQUATION_MIN: number;
    const GL_ALPHA_EQUATION_MAX: number;
    const GL_ALPHA_EQUATION_SUBTRACT: number;
    const GL_ALPHA_EQUATION_REVERSE_SUBTRACT: number;
    const GL_ALPHA_FUNCTION_SRC: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR: number;
    const GL_ALPHA_FUNCTION_SRC_ALPHA: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA: number;
    const GL_ALPHA_FUNCTION_DST_ALPHA: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA: number;
    const GL_ALPHA_FUNCTION_DST_COLOR: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR: number;
    const GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED: number;
    const GL_ALPHA_FUNCTION_CONSTANT_COLOR: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR: number;
    const GL_ALPHA_FUNCTION_CONSTANT_ALPHA: number;
    const GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA: number;
}
export var CullMode: any;
export class DataBuffer {
    references: number;
    capacity: number;
    is32Bits: boolean;
    uniqueId: number;
    get underlyingResource(): any;
}
export namespace DataBuffer {
    const _Counter: number;
}
export function DecodeBase64ToBinary(base64Data: any): ArrayBufferLike;
export function DecodeBase64ToString(base64Data: any): string;
export function DecodeBase64UrlToBinary(uri: any): ArrayBufferLike;
export function DecodeBase64UrlToString(uri: any): string;
export class DeepCopier {
    static DeepCopy(source: any, destination: any, doNotCopyList: any, mustCopyList: any): void;
}
export class DepthCullingState {
    constructor(reset?: boolean);
    _isDepthTestDirty: boolean;
    _isDepthMaskDirty: boolean;
    _isDepthFuncDirty: boolean;
    _isCullFaceDirty: boolean;
    _isCullDirty: boolean;
    _isZOffsetDirty: boolean;
    _isFrontFaceDirty: boolean;
    get isDirty(): boolean;
    set zOffset(arg: any);
    get zOffset(): any;
    _zOffset: any;
    set zOffsetUnits(arg: any);
    get zOffsetUnits(): any;
    _zOffsetUnits: any;
    set cullFace(arg: any);
    get cullFace(): any;
    _cullFace: any;
    set cull(arg: any);
    get cull(): any;
    _cull: any;
    set depthFunc(arg: any);
    get depthFunc(): any;
    _depthFunc: any;
    set depthMask(arg: any);
    get depthMask(): any;
    _depthMask: any;
    set depthTest(arg: any);
    get depthTest(): any;
    _depthTest: any;
    set frontFace(arg: any);
    get frontFace(): any;
    _frontFace: any;
    reset(): void;
    apply(gl: any): void;
}
export var DeviceLostReason: any;
export namespace DomManagement {
    export { IsWindowObjectExist };
    export { IsNavigatorAvailable };
    export { IsDocumentAvailable };
    export { GetDOMTextContent };
}
export class DrawWrapper {
    static IsWrapper(effect: any): boolean;
    static GetEffect(effect: any): any;
    constructor(engine: any, createMaterialContext?: boolean);
    effect: any;
    defines: any;
    drawContext: any;
    materialContext: any;
    setEffect(effect: any, defines: any, resetContext?: boolean): void;
    dispose(): void;
}
export class Effect {
    static set ShadersRepository(arg: string);
    static get ShadersRepository(): string;
    static RegisterShader(name: any, pixelShader: any, vertexShader: any, shaderLanguage?: any): void;
    static ResetCache(): void;
    constructor(baseName: any, attributesNamesOrOptions: any, uniformsNamesOrEngine: any, samplers: any, engine: any, defines: any, fallbacks: any, onCompiled: any, onError: any, indexParameters: any, key?: string, shaderLanguage?: any);
    name: any;
    defines: any;
    onCompiled: any;
    onError: any;
    onBind: any;
    uniqueId: number;
    onCompileObservable: Observable;
    onErrorObservable: Observable;
    _onBindObservable: Observable;
    _wasPreviouslyReady: boolean;
    _bonesComputationForcedToCPU: boolean;
    _uniformBuffersNames: {};
    _multiTarget: boolean;
    _samplers: {};
    _isReady: boolean;
    _compilationError: string;
    _allFallbacksProcessed: boolean;
    _uniforms: {};
    _key: string;
    _fallbacks: any;
    _vertexSourceCodeOverride: string;
    _fragmentSourceCodeOverride: string;
    _transformFeedbackVaryings: any;
    _pipelineContext: any;
    _vertexSourceCode: string;
    _fragmentSourceCode: string;
    _rawVertexSourceCode: string;
    _rawFragmentSourceCode: string;
    _engine: any;
    _attributesNames: any;
    _uniformsNames: any;
    _samplerList: any;
    _indexParameters: any;
    _shaderLanguage: any;
    _uniformBuffersNamesList: any;
    _attributeLocationByName: {};
    _processingContext: any;
    get onBindObservable(): Observable;
    _useFinalCode(migratedVertexCode: any, migratedFragmentCode: any, baseName: any): void;
    get key(): string;
    isReady(): any;
    _isReadyInternal(): any;
    getEngine(): any;
    getPipelineContext(): any;
    getAttributesNames(): any;
    getAttributeLocation(index: any): any;
    getAttributeLocationByName(name: any): any;
    getAttributesCount(): number;
    getUniformIndex(uniformName: any): any;
    getUniform(uniformName: any): any;
    getSamplers(): any;
    getUniformNames(): any;
    getUniformBuffersNames(): any;
    getIndexParameters(): any;
    getCompilationError(): string;
    allFallbacksProcessed(): boolean;
    executeWhenCompiled(func: any): void;
    _checkIsReady(previousPipelineContext: any): void;
    _loadShader(shader: any, key: any, optionalKey: any, callback: any): void;
    get vertexSourceCode(): any;
    get fragmentSourceCode(): any;
    get rawVertexSourceCode(): string;
    get rawFragmentSourceCode(): string;
    _rebuildProgram(vertexSourceCode: any, fragmentSourceCode: any, onCompiled: any, onError: any): void;
    _prepareEffect(): void;
    _attributes: any[];
    _getShaderCodeAndErrorLine(code: any, error: any, isFragment: any): any[];
    _processCompilationErrors(e: any, previousPipelineContext?: any): void;
    get isSupported(): boolean;
    _bindTexture(channel: any, texture: any): void;
    setTexture(channel: any, texture: any): void;
    setDepthStencilTexture(channel: any, texture: any): void;
    setTextureArray(channel: any, textures: any): void;
    setTextureFromPostProcess(channel: any, postProcess: any): void;
    setTextureFromPostProcessOutput(channel: any, postProcess: any): void;
    bindUniformBuffer(buffer: any, name: any): void;
    bindUniformBlock(blockName: any, index: any): void;
    setInt(uniformName: any, value: any): Effect;
    setInt2(uniformName: any, x: any, y: any): Effect;
    setInt3(uniformName: any, x: any, y: any, z: any): Effect;
    setInt4(uniformName: any, x: any, y: any, z: any, w: any): Effect;
    setIntArray(uniformName: any, array: any): Effect;
    setIntArray2(uniformName: any, array: any): Effect;
    setIntArray3(uniformName: any, array: any): Effect;
    setIntArray4(uniformName: any, array: any): Effect;
    setFloatArray(uniformName: any, array: any): Effect;
    setFloatArray2(uniformName: any, array: any): Effect;
    setFloatArray3(uniformName: any, array: any): Effect;
    setFloatArray4(uniformName: any, array: any): Effect;
    setArray(uniformName: any, array: any): Effect;
    setArray2(uniformName: any, array: any): Effect;
    setArray3(uniformName: any, array: any): Effect;
    setArray4(uniformName: any, array: any): Effect;
    setMatrices(uniformName: any, matrices: any): Effect;
    setMatrix(uniformName: any, matrix: any): Effect;
    setMatrix3x3(uniformName: any, matrix: any): Effect;
    setMatrix2x2(uniformName: any, matrix: any): Effect;
    setFloat(uniformName: any, value: any): Effect;
    setBool(uniformName: any, bool: any): Effect;
    setVector2(uniformName: any, vector2: any): Effect;
    setFloat2(uniformName: any, x: any, y: any): Effect;
    setVector3(uniformName: any, vector3: any): Effect;
    setFloat3(uniformName: any, x: any, y: any, z: any): Effect;
    setVector4(uniformName: any, vector4: any): Effect;
    setFloat4(uniformName: any, x: any, y: any, z: any, w: any): Effect;
    setColor3(uniformName: any, color3: any): Effect;
    setColor4(uniformName: any, color3: any, alpha: any): Effect;
    setDirectColor4(uniformName: any, color4: any): Effect;
    dispose(): void;
}
export namespace Effect {
    export const LogShaderCodeOnCompilationError: boolean;
    export const _uniqueIdSeed: number;
    export const _baseCache: {};
    import ShadersStore = ShaderStore.ShadersStore;
    export { ShadersStore };
    import IncludesShadersStore = ShaderStore.IncludesShadersStore;
    export { IncludesShadersStore };
}
export function EncodeArrayBufferToBase64(buffer: any): string;
export function EndsWith(str: any, suffix: any): boolean;
export class Engine extends ThinEngine {
    static get Instances(): any[];
    static get LastCreatedEngine(): any;
    static get LastCreatedScene(): any;
    static MarkAllMaterialsAsDirty(flag: any, predicate: any): void;
    static DefaultLoadingScreenFactory(canvas: any): void;
    static _RequestPointerlock(element: any): void;
    static _ExitPointerlock(): void;
    static _RequestFullscreen(element: any): void;
    static _ExitFullscreen(): void;
    constructor(canvasOrContext: any, antialias: any, options: any, adaptToDeviceRatio?: boolean);
    enableOfflineSupport: boolean;
    disableManifestCheck: boolean;
    scenes: any[];
    _virtualScenes: any[];
    onNewSceneAddedObservable: Observable;
    postProcesses: any[];
    isPointerLock: boolean;
    onResizeObservable: Observable;
    onCanvasBlurObservable: Observable;
    onCanvasFocusObservable: Observable;
    onCanvasPointerOutObservable: Observable;
    onBeginFrameObservable: Observable;
    customAnimationFrameRequester: any;
    onEndFrameObservable: Observable;
    onBeforeShaderCompilationObservable: Observable;
    onAfterShaderCompilationObservable: Observable;
    _deterministicLockstep: boolean;
    _lockstepMaxSteps: any;
    _timeStep: any;
    _fps: number;
    _deltaTime: number;
    _drawCalls: PerfCounter;
    canvasTabIndex: number;
    disablePerformanceMonitorInBackground: boolean;
    _performanceMonitor: PerformanceMonitor;
    _compatibilityMode: boolean;
    currentRenderPassId: number;
    _renderPassNames: string[];
    _onFullscreenChange: () => void;
    _onPointerLockChange: () => void;
    createImageBitmap(image: any, options: any): Promise<ImageBitmap>;
    resizeImageBitmap(image: any, bufferWidth: any, bufferHeight: any): any;
    get performanceMonitor(): PerformanceMonitor;
    set compatibilityMode(arg: boolean);
    get compatibilityMode(): boolean;
    getInputElement(): any;
    _onCanvasFocus: () => void;
    _onCanvasBlur: () => void;
    _onBlur: () => void;
    _onFocus: () => void;
    _onCanvasPointerOut: (ev: any) => void;
    getAspectRatio(viewportOwner: any, useScreen?: boolean): number;
    getScreenAspectRatio(): number;
    getRenderingCanvasClientRect(): any;
    getInputElementClientRect(): any;
    isDeterministicLockStep(): boolean;
    getLockstepMaxSteps(): any;
    getTimeStep(): number;
    generateMipMapsForCubemap(texture: any, unbind?: boolean): void;
    getDepthBuffer(): any;
    setDepthBuffer(enable: any): void;
    getDepthWrite(): any;
    setDepthWrite(enable: any): void;
    getStencilBuffer(): any;
    setStencilBuffer(enable: any): void;
    getStencilMask(): any;
    setStencilMask(mask: any): void;
    getStencilFunction(): any;
    getStencilFunctionReference(): any;
    getStencilFunctionMask(): any;
    setStencilFunction(stencilFunc: any): void;
    setStencilFunctionReference(reference: any): void;
    setStencilFunctionMask(mask: any): void;
    getStencilOperationFail(): any;
    getStencilOperationDepthFail(): any;
    getStencilOperationPass(): any;
    setStencilOperationFail(operation: any): void;
    setStencilOperationDepthFail(operation: any): void;
    setStencilOperationPass(operation: any): void;
    setDitheringState(value: any): void;
    setRasterizerState(value: any): void;
    getDepthFunction(): any;
    setDepthFunction(depthFunc: any): void;
    setDepthFunctionToGreater(): void;
    setDepthFunctionToGreaterOrEqual(): void;
    setDepthFunctionToLess(): void;
    setDepthFunctionToLessOrEqual(): void;
    cacheStencilState(): void;
    _cachedStencilBuffer: any;
    _cachedStencilFunction: any;
    _cachedStencilMask: any;
    _cachedStencilOperationPass: any;
    _cachedStencilOperationFail: any;
    _cachedStencilOperationDepthFail: any;
    _cachedStencilReference: any;
    restoreStencilState(): void;
    setDirectViewport(x: any, y: any, width: any, height: any): any;
    scissorClear(x: any, y: any, width: any, height: any, clearColor: any): void;
    enableScissor(x: any, y: any, width: any, height: any): void;
    disableScissor(): void;
    initWebVR(): void;
    _prepareVRComponent(): void;
    _connectVREvents(canvas: any, document: any): void;
    _submitVRFrame(): void;
    disableVR(): void;
    isVRPresenting(): boolean;
    _requestVRFrame(): void;
    _loadFileAsync(url: any, offlineProvider: any, useArrayBuffer: any): Promise<any>;
    getVertexShaderSource(program: any): any;
    getFragmentShaderSource(program: any): any;
    setDepthStencilTexture(channel: any, uniform: any, texture: any, name: any): void;
    setTextureFromPostProcess(channel: any, postProcess: any, name: any): void;
    setTextureFromPostProcessOutput(channel: any, postProcess: any, name: any): void;
    _renderFrame(): void;
    _renderViews(): boolean;
    switchFullscreen(requestPointerLock: any): void;
    enterFullscreen(requestPointerLock: any): void;
    _pointerLockRequested: any;
    exitFullscreen(): void;
    enterPointerlock(): void;
    exitPointerlock(): void;
    getRenderPassNames(): string[];
    getCurrentRenderPassName(): string;
    createRenderPassId(name: any): number;
    releaseRenderPassId(id: any): void;
    _rescalePostProcess: any;
    getFps(): number;
    getDeltaTime(): number;
    _measureFps(): void;
    _uploadImageToTexture(texture: any, image: any, faceIndex?: number, lod?: number): void;
    updateTextureComparisonFunction(texture: any, comparisonFunction: any): void;
    createInstancesBuffer(capacity: any): WebGLDataBuffer;
    deleteInstancesBuffer(buffer: any): void;
    _clientWaitAsync(sync: any, flags?: number, interval_ms?: number): Promise<any>;
    _readPixelsAsync(x: any, y: any, w: any, h: any, format: any, type: any, outputBuffer: any): Promise<any>;
    _disableTouchAction(): void;
    displayLoadingUI(): void;
    hideLoadingUI(): void;
    set loadingScreen(arg: any);
    get loadingScreen(): any;
    _loadingScreen: any;
    set loadingUIText(arg: any);
    set loadingUIBackgroundColor(arg: any);
    createVideoElement(constraints: any): HTMLVideoElement;
    getFontOffset(font: any): {
        ascent: number;
        height: number;
        descent: number;
    };
}
export namespace Engine {
    import ALPHA_DISABLE_1 = Constants.ALPHA_DISABLE;
    export { ALPHA_DISABLE_1 as ALPHA_DISABLE };
    import ALPHA_ADD_1 = Constants.ALPHA_ADD;
    export { ALPHA_ADD_1 as ALPHA_ADD };
    import ALPHA_COMBINE_1 = Constants.ALPHA_COMBINE;
    export { ALPHA_COMBINE_1 as ALPHA_COMBINE };
    import ALPHA_SUBTRACT_1 = Constants.ALPHA_SUBTRACT;
    export { ALPHA_SUBTRACT_1 as ALPHA_SUBTRACT };
    import ALPHA_MULTIPLY_1 = Constants.ALPHA_MULTIPLY;
    export { ALPHA_MULTIPLY_1 as ALPHA_MULTIPLY };
    import ALPHA_MAXIMIZED_1 = Constants.ALPHA_MAXIMIZED;
    export { ALPHA_MAXIMIZED_1 as ALPHA_MAXIMIZED };
    import ALPHA_ONEONE_1 = Constants.ALPHA_ONEONE;
    export { ALPHA_ONEONE_1 as ALPHA_ONEONE };
    import ALPHA_PREMULTIPLIED_1 = Constants.ALPHA_PREMULTIPLIED;
    export { ALPHA_PREMULTIPLIED_1 as ALPHA_PREMULTIPLIED };
    import ALPHA_PREMULTIPLIED_PORTERDUFF_1 = Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;
    export { ALPHA_PREMULTIPLIED_PORTERDUFF_1 as ALPHA_PREMULTIPLIED_PORTERDUFF };
    import ALPHA_INTERPOLATE_1 = Constants.ALPHA_INTERPOLATE;
    export { ALPHA_INTERPOLATE_1 as ALPHA_INTERPOLATE };
    import ALPHA_SCREENMODE_1 = Constants.ALPHA_SCREENMODE;
    export { ALPHA_SCREENMODE_1 as ALPHA_SCREENMODE };
    import DELAYLOADSTATE_NONE_1 = Constants.DELAYLOADSTATE_NONE;
    export { DELAYLOADSTATE_NONE_1 as DELAYLOADSTATE_NONE };
    import DELAYLOADSTATE_LOADED_1 = Constants.DELAYLOADSTATE_LOADED;
    export { DELAYLOADSTATE_LOADED_1 as DELAYLOADSTATE_LOADED };
    import DELAYLOADSTATE_LOADING_1 = Constants.DELAYLOADSTATE_LOADING;
    export { DELAYLOADSTATE_LOADING_1 as DELAYLOADSTATE_LOADING };
    import DELAYLOADSTATE_NOTLOADED_1 = Constants.DELAYLOADSTATE_NOTLOADED;
    export { DELAYLOADSTATE_NOTLOADED_1 as DELAYLOADSTATE_NOTLOADED };
    import NEVER_1 = Constants.NEVER;
    export { NEVER_1 as NEVER };
    import ALWAYS_1 = Constants.ALWAYS;
    export { ALWAYS_1 as ALWAYS };
    import LESS_1 = Constants.LESS;
    export { LESS_1 as LESS };
    import EQUAL_1 = Constants.EQUAL;
    export { EQUAL_1 as EQUAL };
    import LEQUAL_1 = Constants.LEQUAL;
    export { LEQUAL_1 as LEQUAL };
    import GREATER_1 = Constants.GREATER;
    export { GREATER_1 as GREATER };
    import GEQUAL_1 = Constants.GEQUAL;
    export { GEQUAL_1 as GEQUAL };
    import NOTEQUAL_1 = Constants.NOTEQUAL;
    export { NOTEQUAL_1 as NOTEQUAL };
    import KEEP_1 = Constants.KEEP;
    export { KEEP_1 as KEEP };
    import REPLACE_1 = Constants.REPLACE;
    export { REPLACE_1 as REPLACE };
    import INCR_1 = Constants.INCR;
    export { INCR_1 as INCR };
    import DECR_1 = Constants.DECR;
    export { DECR_1 as DECR };
    import INVERT_1 = Constants.INVERT;
    export { INVERT_1 as INVERT };
    import INCR_WRAP_1 = Constants.INCR_WRAP;
    export { INCR_WRAP_1 as INCR_WRAP };
    import DECR_WRAP_1 = Constants.DECR_WRAP;
    export { DECR_WRAP_1 as DECR_WRAP };
    import TEXTURE_CLAMP_ADDRESSMODE_1 = Constants.TEXTURE_CLAMP_ADDRESSMODE;
    export { TEXTURE_CLAMP_ADDRESSMODE_1 as TEXTURE_CLAMP_ADDRESSMODE };
    import TEXTURE_WRAP_ADDRESSMODE_1 = Constants.TEXTURE_WRAP_ADDRESSMODE;
    export { TEXTURE_WRAP_ADDRESSMODE_1 as TEXTURE_WRAP_ADDRESSMODE };
    import TEXTURE_MIRROR_ADDRESSMODE_1 = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    export { TEXTURE_MIRROR_ADDRESSMODE_1 as TEXTURE_MIRROR_ADDRESSMODE };
    import TEXTUREFORMAT_ALPHA_1 = Constants.TEXTUREFORMAT_ALPHA;
    export { TEXTUREFORMAT_ALPHA_1 as TEXTUREFORMAT_ALPHA };
    import TEXTUREFORMAT_LUMINANCE_1 = Constants.TEXTUREFORMAT_LUMINANCE;
    export { TEXTUREFORMAT_LUMINANCE_1 as TEXTUREFORMAT_LUMINANCE };
    import TEXTUREFORMAT_LUMINANCE_ALPHA_1 = Constants.TEXTUREFORMAT_LUMINANCE_ALPHA;
    export { TEXTUREFORMAT_LUMINANCE_ALPHA_1 as TEXTUREFORMAT_LUMINANCE_ALPHA };
    import TEXTUREFORMAT_RGB_1 = Constants.TEXTUREFORMAT_RGB;
    export { TEXTUREFORMAT_RGB_1 as TEXTUREFORMAT_RGB };
    import TEXTUREFORMAT_RGBA_1 = Constants.TEXTUREFORMAT_RGBA;
    export { TEXTUREFORMAT_RGBA_1 as TEXTUREFORMAT_RGBA };
    import TEXTUREFORMAT_RED_1 = Constants.TEXTUREFORMAT_RED;
    export { TEXTUREFORMAT_RED_1 as TEXTUREFORMAT_RED };
    import TEXTUREFORMAT_R_1 = Constants.TEXTUREFORMAT_R;
    export { TEXTUREFORMAT_R_1 as TEXTUREFORMAT_R };
    import TEXTUREFORMAT_RG_1 = Constants.TEXTUREFORMAT_RG;
    export { TEXTUREFORMAT_RG_1 as TEXTUREFORMAT_RG };
    import TEXTUREFORMAT_RED_INTEGER_1 = Constants.TEXTUREFORMAT_RED_INTEGER;
    export { TEXTUREFORMAT_RED_INTEGER_1 as TEXTUREFORMAT_RED_INTEGER };
    import TEXTUREFORMAT_R_INTEGER_1 = Constants.TEXTUREFORMAT_R_INTEGER;
    export { TEXTUREFORMAT_R_INTEGER_1 as TEXTUREFORMAT_R_INTEGER };
    import TEXTUREFORMAT_RG_INTEGER_1 = Constants.TEXTUREFORMAT_RG_INTEGER;
    export { TEXTUREFORMAT_RG_INTEGER_1 as TEXTUREFORMAT_RG_INTEGER };
    import TEXTUREFORMAT_RGB_INTEGER_1 = Constants.TEXTUREFORMAT_RGB_INTEGER;
    export { TEXTUREFORMAT_RGB_INTEGER_1 as TEXTUREFORMAT_RGB_INTEGER };
    import TEXTUREFORMAT_RGBA_INTEGER_1 = Constants.TEXTUREFORMAT_RGBA_INTEGER;
    export { TEXTUREFORMAT_RGBA_INTEGER_1 as TEXTUREFORMAT_RGBA_INTEGER };
    import TEXTURETYPE_UNSIGNED_BYTE_1 = Constants.TEXTURETYPE_UNSIGNED_BYTE;
    export { TEXTURETYPE_UNSIGNED_BYTE_1 as TEXTURETYPE_UNSIGNED_BYTE };
    import TEXTURETYPE_UNSIGNED_INT_1 = Constants.TEXTURETYPE_UNSIGNED_INT;
    export { TEXTURETYPE_UNSIGNED_INT_1 as TEXTURETYPE_UNSIGNED_INT };
    import TEXTURETYPE_FLOAT_1 = Constants.TEXTURETYPE_FLOAT;
    export { TEXTURETYPE_FLOAT_1 as TEXTURETYPE_FLOAT };
    import TEXTURETYPE_HALF_FLOAT_1 = Constants.TEXTURETYPE_HALF_FLOAT;
    export { TEXTURETYPE_HALF_FLOAT_1 as TEXTURETYPE_HALF_FLOAT };
    import TEXTURETYPE_BYTE_1 = Constants.TEXTURETYPE_BYTE;
    export { TEXTURETYPE_BYTE_1 as TEXTURETYPE_BYTE };
    import TEXTURETYPE_SHORT_1 = Constants.TEXTURETYPE_SHORT;
    export { TEXTURETYPE_SHORT_1 as TEXTURETYPE_SHORT };
    import TEXTURETYPE_UNSIGNED_SHORT_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT;
    export { TEXTURETYPE_UNSIGNED_SHORT_1 as TEXTURETYPE_UNSIGNED_SHORT };
    import TEXTURETYPE_INT_1 = Constants.TEXTURETYPE_INT;
    export { TEXTURETYPE_INT_1 as TEXTURETYPE_INT };
    import TEXTURETYPE_UNSIGNED_INTEGER_1 = Constants.TEXTURETYPE_UNSIGNED_INTEGER;
    export { TEXTURETYPE_UNSIGNED_INTEGER_1 as TEXTURETYPE_UNSIGNED_INTEGER };
    import TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;
    export { TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4_1 as TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 };
    import TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1_1 as TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 };
    import TEXTURETYPE_UNSIGNED_SHORT_5_6_5_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_6_5_1 as TEXTURETYPE_UNSIGNED_SHORT_5_6_5 };
    import TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV_1 = Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;
    export { TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV_1 as TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV };
    import TEXTURETYPE_UNSIGNED_INT_24_8_1 = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;
    export { TEXTURETYPE_UNSIGNED_INT_24_8_1 as TEXTURETYPE_UNSIGNED_INT_24_8 };
    import TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV_1 = Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;
    export { TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV_1 as TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV };
    import TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV_1 = Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;
    export { TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV_1 as TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV };
    import TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV_1 = Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;
    export { TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV_1 as TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV };
    import TEXTURE_NEAREST_SAMPLINGMODE_1 = Constants.TEXTURE_NEAREST_SAMPLINGMODE;
    export { TEXTURE_NEAREST_SAMPLINGMODE_1 as TEXTURE_NEAREST_SAMPLINGMODE };
    import TEXTURE_BILINEAR_SAMPLINGMODE_1 = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;
    export { TEXTURE_BILINEAR_SAMPLINGMODE_1 as TEXTURE_BILINEAR_SAMPLINGMODE };
    import TEXTURE_TRILINEAR_SAMPLINGMODE_1 = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;
    export { TEXTURE_TRILINEAR_SAMPLINGMODE_1 as TEXTURE_TRILINEAR_SAMPLINGMODE };
    import TEXTURE_NEAREST_NEAREST_MIPLINEAR_1 = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR;
    export { TEXTURE_NEAREST_NEAREST_MIPLINEAR_1 as TEXTURE_NEAREST_NEAREST_MIPLINEAR };
    import TEXTURE_LINEAR_LINEAR_MIPNEAREST_1 = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;
    export { TEXTURE_LINEAR_LINEAR_MIPNEAREST_1 as TEXTURE_LINEAR_LINEAR_MIPNEAREST };
    import TEXTURE_LINEAR_LINEAR_MIPLINEAR_1 = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;
    export { TEXTURE_LINEAR_LINEAR_MIPLINEAR_1 as TEXTURE_LINEAR_LINEAR_MIPLINEAR };
    import TEXTURE_NEAREST_NEAREST_MIPNEAREST_1 = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;
    export { TEXTURE_NEAREST_NEAREST_MIPNEAREST_1 as TEXTURE_NEAREST_NEAREST_MIPNEAREST };
    import TEXTURE_NEAREST_LINEAR_MIPNEAREST_1 = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;
    export { TEXTURE_NEAREST_LINEAR_MIPNEAREST_1 as TEXTURE_NEAREST_LINEAR_MIPNEAREST };
    import TEXTURE_NEAREST_LINEAR_MIPLINEAR_1 = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;
    export { TEXTURE_NEAREST_LINEAR_MIPLINEAR_1 as TEXTURE_NEAREST_LINEAR_MIPLINEAR };
    import TEXTURE_NEAREST_LINEAR_1 = Constants.TEXTURE_NEAREST_LINEAR;
    export { TEXTURE_NEAREST_LINEAR_1 as TEXTURE_NEAREST_LINEAR };
    import TEXTURE_NEAREST_NEAREST_1 = Constants.TEXTURE_NEAREST_NEAREST;
    export { TEXTURE_NEAREST_NEAREST_1 as TEXTURE_NEAREST_NEAREST };
    import TEXTURE_LINEAR_NEAREST_MIPNEAREST_1 = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;
    export { TEXTURE_LINEAR_NEAREST_MIPNEAREST_1 as TEXTURE_LINEAR_NEAREST_MIPNEAREST };
    import TEXTURE_LINEAR_NEAREST_MIPLINEAR_1 = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;
    export { TEXTURE_LINEAR_NEAREST_MIPLINEAR_1 as TEXTURE_LINEAR_NEAREST_MIPLINEAR };
    import TEXTURE_LINEAR_LINEAR_1 = Constants.TEXTURE_LINEAR_LINEAR;
    export { TEXTURE_LINEAR_LINEAR_1 as TEXTURE_LINEAR_LINEAR };
    import TEXTURE_LINEAR_NEAREST_1 = Constants.TEXTURE_LINEAR_NEAREST;
    export { TEXTURE_LINEAR_NEAREST_1 as TEXTURE_LINEAR_NEAREST };
    import TEXTURE_EXPLICIT_MODE_1 = Constants.TEXTURE_EXPLICIT_MODE;
    export { TEXTURE_EXPLICIT_MODE_1 as TEXTURE_EXPLICIT_MODE };
    import TEXTURE_SPHERICAL_MODE_1 = Constants.TEXTURE_SPHERICAL_MODE;
    export { TEXTURE_SPHERICAL_MODE_1 as TEXTURE_SPHERICAL_MODE };
    import TEXTURE_PLANAR_MODE_1 = Constants.TEXTURE_PLANAR_MODE;
    export { TEXTURE_PLANAR_MODE_1 as TEXTURE_PLANAR_MODE };
    import TEXTURE_CUBIC_MODE_1 = Constants.TEXTURE_CUBIC_MODE;
    export { TEXTURE_CUBIC_MODE_1 as TEXTURE_CUBIC_MODE };
    import TEXTURE_PROJECTION_MODE_1 = Constants.TEXTURE_PROJECTION_MODE;
    export { TEXTURE_PROJECTION_MODE_1 as TEXTURE_PROJECTION_MODE };
    import TEXTURE_SKYBOX_MODE_1 = Constants.TEXTURE_SKYBOX_MODE;
    export { TEXTURE_SKYBOX_MODE_1 as TEXTURE_SKYBOX_MODE };
    import TEXTURE_INVCUBIC_MODE_1 = Constants.TEXTURE_INVCUBIC_MODE;
    export { TEXTURE_INVCUBIC_MODE_1 as TEXTURE_INVCUBIC_MODE };
    import TEXTURE_EQUIRECTANGULAR_MODE_1 = Constants.TEXTURE_EQUIRECTANGULAR_MODE;
    export { TEXTURE_EQUIRECTANGULAR_MODE_1 as TEXTURE_EQUIRECTANGULAR_MODE };
    import TEXTURE_FIXED_EQUIRECTANGULAR_MODE_1 = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MODE_1 as TEXTURE_FIXED_EQUIRECTANGULAR_MODE };
    import TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE_1 = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE_1 as TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE };
    import SCALEMODE_FLOOR_1 = Constants.SCALEMODE_FLOOR;
    export { SCALEMODE_FLOOR_1 as SCALEMODE_FLOOR };
    import SCALEMODE_NEAREST_1 = Constants.SCALEMODE_NEAREST;
    export { SCALEMODE_NEAREST_1 as SCALEMODE_NEAREST };
    import SCALEMODE_CEILING_1 = Constants.SCALEMODE_CEILING;
    export { SCALEMODE_CEILING_1 as SCALEMODE_CEILING };
    export const _RescalePostProcessFactory: any;
    export const _RenderPassIdCounter: number;
}
export class EngineStore {
    static get LastCreatedEngine(): any;
    static get LastCreatedScene(): any;
}
export namespace EngineStore {
    const Instances: any[];
    const _LastCreatedScene: any;
    const UseFallbackTexture: boolean;
    const FallbackTexture: string;
}
export var ErrorFilter: any;
export class EventState {
    constructor(mask: any, skipNextObservers: boolean, target: any, currentTarget: any);
    initialize(mask: any, skipNextObservers: boolean, target: any, currentTarget: any): EventState;
    mask: any;
    skipNextObservers: boolean;
    target: any;
    currentTarget: any;
}
export class ExternalTexture {
    static IsExternalTexture(texture: any): boolean;
    constructor(video: any);
    useMipMaps: boolean;
    type: number;
    _video: any;
    uniqueId: number;
    getClassName(): string;
    get underlyingResource(): any;
    isReady(): boolean;
    dispose(): void;
}
export var FeatureName: any;
export let FileTools: any;
export namespace FileToolsOptions {
    function DefaultRetryStrategy(url: any, request: any, retryIndex: any): number;
    const BaseUrl: string;
    const CorsBehavior: string;
    function PreprocessUrl(url: any): any;
}
export class FilesInputStore {
}
export namespace FilesInputStore {
    const FilesToLoad: {};
}
export var FilterMode: any;
export function FromHalfFloat(value: any): number;
export var FrontFace: any;
export function GetClass(fqdn: any): any;
export function GetDOMTextContent(element: any): string;
export var IndexFormat: any;
export var InputStepMode: any;
export class InternalTexture extends TextureSampler {
    constructor(engine: any, source: any, delayAllocation?: boolean);
    isReady: boolean;
    isCube: boolean;
    is3D: boolean;
    is2DArray: boolean;
    isMultiview: boolean;
    url: string;
    generateMipMaps: boolean;
    samples: number;
    type: number;
    format: number;
    onLoadedObservable: Observable;
    onErrorObservable: Observable;
    onRebuildCallback: any;
    width: number;
    height: number;
    depth: number;
    baseWidth: number;
    baseHeight: number;
    baseDepth: number;
    invertY: boolean;
    _invertVScale: boolean;
    _associatedChannel: number;
    _source: any;
    _buffer: any;
    _bufferView: any;
    _bufferViewArray: any;
    _bufferViewArrayArray: any;
    _size: number;
    _extension: string;
    _files: any;
    _workingCanvas: any;
    _workingContext: any;
    _cachedCoordinatesMode: any;
    _isDisabled: boolean;
    _compression: any;
    _sphericalPolynomial: any;
    _sphericalPolynomialPromise: any;
    _sphericalPolynomialComputed: boolean;
    _lodGenerationScale: number;
    _lodGenerationOffset: number;
    _useSRGBBuffer: boolean;
    _lodTextureHigh: any;
    _lodTextureMid: any;
    _lodTextureLow: any;
    _isRGBD: boolean;
    _linearSpecularLOD: boolean;
    _irradianceTexture: any;
    _hardwareTexture: any;
    _references: number;
    _gammaSpace: any;
    _engine: any;
    _uniqueId: number;
    get uniqueId(): number;
    getEngine(): any;
    get source(): any;
    incrementReferences(): void;
    updateSize(width: any, height: any, depth?: number): void;
    _rebuild(): void;
    _swapAndDie(target: any, swapAll?: boolean): void;
    dispose(): void;
}
export namespace InternalTexture {
    const _Counter_1: number;
    export { _Counter_1 as _Counter };
}
export var InternalTextureSource: any;
export function IsBase64DataUrl(uri: any): boolean;
export function IsDocumentAvailable(): boolean;
export function IsFileURL(): boolean;
export function IsNavigatorAvailable(): boolean;
export function IsWindowObjectExist(): boolean;
export function LoadFile(fileOrUrl: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any, onOpened: any): {
    onCompleteObservable: Observable;
    abort: () => void;
};
export class LoadFileError extends BaseError {
    constructor(message: any, object: any);
    request: WebRequest;
    file: any;
}
export function LoadImage(input: any, onLoad: any, onError: any, offlineProvider: any, mimeType: string, imageBitmapOptions: any): HTMLImageElement;
export var LoadOp: any;
export class Logger {
    static _CheckLimit(message: any, limit: any): boolean;
    static _GenerateLimitMessage(message: any, messageType: any): void;
    static _AddLogEntry(entry: any): void;
    static _FormatMessage(message: any): string;
    static _LogDisabled(message: any, limit: any): void;
    static _LogEnabled(message: any, limit: any): void;
    static _WarnDisabled(message: any, limit: any): void;
    static _WarnEnabled(message: any, limit: any): void;
    static _ErrorDisabled(message: any, limit: any): void;
    static _ErrorEnabled(message: any, limit: any): void;
    static get LogCache(): string;
    static ClearLogCache(): void;
    static set LogLevels(arg: any);
}
export namespace Logger {
    export const NoneLogLevel: number;
    export const MessageLogLevel: number;
    export const WarningLogLevel: number;
    export const ErrorLogLevel: number;
    export const AllLogLevel: number;
    export const MessageLimitReached: string;
    export const _LogCache: string;
    export const _LogLimitOutputs: {};
    export const errorsCount: number;
    import Log = Logger._LogEnabled;
    export { Log };
    import Warn = Logger._WarnEnabled;
    export { Warn };
    import Error = Logger._ErrorEnabled;
    export { Error };
}
export var MapMode: any;
export class Observable {
    static FromPromise(promise: any, onErrorObservable: any): Observable;
    constructor(onObserverAdded: any);
    _observers: any[];
    _eventState: EventState;
    _onObserverAdded: any;
    get observers(): any[];
    add(callback: any, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Observer;
    addOnce(callback: any): Observer;
    remove(observer: any): boolean;
    removeCallback(callback: any, scope: any): boolean;
    _deferUnregister(observer: any): void;
    _remove(observer: any): boolean;
    makeObserverTopPriority(observer: any): void;
    makeObserverBottomPriority(observer: any): void;
    notifyObservers(eventData: any, mask: number, target: any, currentTarget: any, userInfo: any): boolean;
    notifyObserversWithPromise(eventData: any, mask: number, target: any, currentTarget: any, userInfo: any): Promise<T>;
    notifyObserver(observer: any, eventData: any, mask?: number): void;
    hasObservers(): boolean;
    clear(): void;
    clone(): Observable;
    hasSpecificMask(mask?: number): boolean;
}
export class Observer {
    constructor(callback: any, mask: any, scope?: any);
    callback: any;
    mask: any;
    scope: any;
    _willBeUnregistered: boolean;
    unregisterOnNextCall: boolean;
}
export class PerfCounter {
    _startMonitoringTime: number;
    _min: number;
    _max: number;
    _average: number;
    _lastSecAverage: number;
    _current: number;
    _totalValueCount: number;
    _totalAccumulated: number;
    _lastSecAccumulated: number;
    _lastSecTime: number;
    _lastSecValueCount: number;
    get min(): number;
    get max(): number;
    get average(): number;
    get lastSecAverage(): number;
    get current(): number;
    get total(): number;
    get count(): number;
    fetchNewFrame(): void;
    addCount(newCount: any, fetchResult: any): void;
    beginMonitoring(): void;
    endMonitoring(newFrame?: boolean): void;
    _fetchResult(): void;
}
export namespace PerfCounter {
    const Enabled: boolean;
}
export class PerformanceConfigurator {
    static SetMatrixPrecision(use64bits: any): void;
}
export namespace PerformanceConfigurator {
    const MatrixUse64Bits: boolean;
    const MatrixTrackPrecisionChange: boolean;
    const MatrixCurrentType: Float32ArrayConstructor;
    const MatrixTrackedMatrices: any[];
}
export class PerformanceMonitor {
    constructor(frameSampleSize?: number);
    _enabled: boolean;
    _rollingFrameTime: RollingAverage;
    sampleFrame(timeMs?: number): void;
    _lastFrameTimeMs: number;
    get averageFrameTime(): number;
    get averageFrameTimeVariance(): number;
    get instantaneousFrameTime(): any;
    get averageFPS(): number;
    get instantaneousFPS(): number;
    get isSaturated(): boolean;
    enable(): void;
    disable(): void;
    get isEnabled(): boolean;
    reset(): void;
}
export var PowerPreference: any;
export class PrecisionDate {
    static get Now(): number;
}
export var PrimitiveTopology: any;
export class PromisePolyfill {
    static Apply(force?: boolean): void;
}
export var QueryType: any;
export function ReadFile(file: any, onSuccess: any, onProgress: any, useArrayBuffer: any, onError: any): {
    onCompleteObservable: Observable;
    abort: () => void;
};
export class ReadFileError extends BaseError {
    constructor(message: any, file: any);
    file: any;
}
export function RegisterClass(className: any, type: any): void;
export var RenderPassTimestampLocation: any;
export function RequestFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any, onOpened: any): {
    onCompleteObservable: Observable;
    abort: () => boolean;
};
export class RequestFileError extends BaseError {
    constructor(message: any, request: any);
    request: any;
}
export class RetryStrategy {
    static ExponentialBackoff(maxRetries?: number, baseInterval?: number): (url: any, request: any, retryIndex: any) => number;
}
export class RollingAverage {
    constructor(length: any);
    _samples: any[];
    add(v: any): void;
    variance: number;
    history(i: any): any;
    isSaturated(): boolean;
    reset(): void;
    average: number;
    _sampleCount: number;
    _pos: number;
    _m2: number;
    _wrapPosition(i: any): number;
}
export var SamplerBindingType: any;
export class Scalar {
    static WithinEpsilon(a: any, b: any, epsilon?: number): boolean;
    static ToHex(i: any): any;
    static Sign(value: any): any;
    static Clamp(value: any, min?: number, max?: number): number;
    static Log2(value: any): number;
    static ILog2(value: any): number;
    static Repeat(value: any, length: any): number;
    static Normalize(value: any, min: any, max: any): number;
    static Denormalize(normalized: any, min: any, max: any): any;
    static DeltaAngle(current: any, target: any): number;
    static PingPong(tx: any, length: any): number;
    static SmoothStep(from: any, to: any, tx: any): number;
    static MoveTowards(current: any, target: any, maxDelta: any): number;
    static MoveTowardsAngle(current: any, target: any, maxDelta: any): number;
    static Lerp(start: any, end: any, amount: any): any;
    static LerpAngle(start: any, end: any, amount: any): any;
    static InverseLerp(a: any, b: any, value: any): number;
    static Hermite(value1: any, tangent1: any, value2: any, tangent2: any, amount: any): number;
    static Hermite1stDerivative(value1: any, tangent1: any, value2: any, tangent2: any, time: any): number;
    static RandomRange(min: any, max: any): any;
    static RangeToPercent(number: any, min: any, max: any): number;
    static PercentToRange(percent: any, min: any, max: any): any;
    static NormalizeRadians(angle: any): any;
    static HCF(a: any, b: any): any;
}
export namespace Scalar {
    const TwoPi: number;
}
export function SetCorsBehavior(url: any, element: any): void;
export class ShaderCodeInliner {
    constructor(sourceCode: any, numMaxIterations?: number);
    debug: boolean;
    _sourceCode: any;
    _numMaxIterations: number;
    _functionDescr: any[];
    inlineToken: string;
    get code(): any;
    processCode(): void;
    _collectFunctions(): void;
    _processInlining(numMaxIterations?: number): boolean;
    _replaceFunctionCallsByCode(): boolean;
    _replaceNames(code: any, sources: any, destinations: any): any;
}
export namespace ShaderCodeInliner {
    const _RegexpFindFunctionNameAndType: RegExp;
}
export var ShaderLanguage: any;
export var ShaderStage: any;
export class ShaderStore {
    static GetShadersRepository(shaderLanguage?: any): string;
    static GetShadersStore(shaderLanguage?: any): {};
    static GetIncludesShadersStore(shaderLanguage?: any): {};
}
export namespace ShaderStore {
    export const ShadersRepository: string;
    const ShadersStore_1: {};
    export { ShadersStore_1 as ShadersStore };
    const IncludesShadersStore_1: {};
    export { IncludesShadersStore_1 as IncludesShadersStore };
    export const ShadersRepositoryWGSL: string;
    export const ShadersStoreWGSL: {};
    export const IncludesShadersStoreWGSL: {};
}
export function StartsWith(str: any, suffix: any): boolean;
export var StencilOperation: any;
export class StencilState {
    reset(): void;
    enabled: any;
    mask: any;
    func: any;
    funcRef: any;
    funcMask: any;
    opStencilFail: any;
    opDepthFail: any;
    opStencilDepthPass: any;
    set stencilFunc(arg: any);
    get stencilFunc(): any;
    set stencilFuncRef(arg: any);
    get stencilFuncRef(): any;
    set stencilFuncMask(arg: any);
    get stencilFuncMask(): any;
    set stencilOpStencilFail(arg: any);
    get stencilOpStencilFail(): any;
    set stencilOpDepthFail(arg: any);
    get stencilOpDepthFail(): any;
    set stencilOpStencilDepthPass(arg: any);
    get stencilOpStencilDepthPass(): any;
    set stencilMask(arg: any);
    get stencilMask(): any;
    set stencilTest(arg: any);
    get stencilTest(): any;
}
export namespace StencilState {
    import ALWAYS_2 = Constants.ALWAYS;
    export { ALWAYS_2 as ALWAYS };
    import KEEP_2 = Constants.KEEP;
    export { KEEP_2 as KEEP };
    import REPLACE_2 = Constants.REPLACE;
    export { REPLACE_2 as REPLACE };
}
export class StencilStateComposer {
    constructor(reset?: boolean);
    _isStencilTestDirty: boolean;
    _isStencilMaskDirty: boolean;
    _isStencilFuncDirty: boolean;
    _isStencilOpDirty: boolean;
    useStencilGlobalOnly: boolean;
    get isDirty(): boolean;
    set func(arg: any);
    get func(): any;
    _func: any;
    set funcRef(arg: any);
    get funcRef(): any;
    _funcRef: any;
    set funcMask(arg: any);
    get funcMask(): any;
    _funcMask: any;
    set opStencilFail(arg: any);
    get opStencilFail(): any;
    _opStencilFail: any;
    set opDepthFail(arg: any);
    get opDepthFail(): any;
    _opDepthFail: any;
    set opStencilDepthPass(arg: any);
    get opStencilDepthPass(): any;
    _opStencilDepthPass: any;
    set mask(arg: any);
    get mask(): any;
    _mask: any;
    set enabled(arg: any);
    get enabled(): any;
    _enabled: any;
    reset(): void;
    stencilMaterial: any;
    apply(gl: any): void;
}
export var StorageTextureAccess: any;
export var StoreOp: any;
export var TextureAspect: any;
export var TextureDimension: any;
export var TextureFormat: any;
export var TextureSampleType: any;
export class TextureSampler {
    samplingMode: number;
    _useMipMaps: boolean;
    _cachedWrapU: any;
    _cachedWrapV: any;
    _cachedWrapR: any;
    _cachedAnisotropicFilteringLevel: any;
    _comparisonFunction: number;
    set wrapU(arg: any);
    get wrapU(): any;
    set wrapV(arg: any);
    get wrapV(): any;
    set wrapR(arg: any);
    get wrapR(): any;
    set anisotropicFilteringLevel(arg: any);
    get anisotropicFilteringLevel(): any;
    set comparisonFunction(arg: number);
    get comparisonFunction(): number;
    set useMipMaps(arg: boolean);
    get useMipMaps(): boolean;
    setParameters(wrapU?: number, wrapV?: number, wrapR?: number, anisotropicFilteringLevel?: number, samplingMode?: number, comparisonFunction?: number): TextureSampler;
    compareSampler(other: any): boolean;
}
export var TextureUsage: any;
export var TextureViewDimension: any;
export class ThinEngine {
    static get NpmPackage(): string;
    static get Version(): string;
    static set ShadersRepository(arg: string);
    static get ShadersRepository(): string;
    static _createCanvas(width: any, height: any): any;
    static _ConcatenateShader(source: any, defines: any, shaderVersion?: string): string;
    static _FileToolsLoadImage(input: any, onLoad: any, onError: any, offlineProvider: any, mimeType: any, imageBitmapOptions: any): void;
    static _FileToolsLoadFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any): void;
    static get IsSupportedAsync(): Promise<boolean>;
    static get IsSupported(): boolean;
    static isSupported(): boolean;
    static get HasMajorPerformanceCaveat(): boolean;
    static CeilingPOT(x: any): any;
    static FloorPOT(x: any): number;
    static NearestPOT(x: any): any;
    static GetExponentOfTwo(value: any, max: any, mode?: number): number;
    static QueueNewFrame(func: any, requester: any): any;
    constructor(canvasOrContext: any, antialias: any, options: any, adaptToDeviceRatio: any);
    forcePOTTextures: boolean;
    isFullscreen: boolean;
    cullBackFaces: any;
    renderEvenInBackground: boolean;
    preventCacheWipeBetweenFrames: boolean;
    validateShaderPrograms: boolean;
    _useReverseDepthBuffer: boolean;
    isNDCHalfZRange: boolean;
    hasOriginBottomLeft: boolean;
    disableUniformBuffers: boolean;
    onDisposeObservable: Observable;
    _frameId: number;
    _uniformBuffers: any[];
    _storageBuffers: any[];
    _webGLVersion: number;
    _windowIsBackground: boolean;
    _highPrecisionShadersAllowed: any;
    _badOS: boolean;
    _badDesktopOS: boolean;
    _renderingQueueLaunched: boolean;
    _activeRenderLoops: any[];
    onContextLostObservable: Observable;
    onContextRestoredObservable: Observable;
    _contextWasLost: boolean;
    _doNotHandleContextLost: boolean;
    disableVertexArrayObjects: boolean;
    _colorWrite: boolean;
    _colorWriteChanged: boolean;
    _depthCullingState: DepthCullingState;
    _stencilStateComposer: StencilStateComposer;
    _stencilState: StencilState;
    _alphaState: AlphaState;
    _alphaMode: number;
    _alphaEquation: number;
    _internalTexturesCache: any[];
    _renderTargetWrapperCache: any[];
    _activeChannel: number;
    _currentTextureChannel: number;
    _boundTexturesCache: {};
    _compiledEffects: {};
    _vertexAttribArraysEnabled: any[];
    _uintIndicesCurrentlySet: boolean;
    _currentBoundBuffer: any[];
    _currentFramebuffer: any;
    _dummyFramebuffer: any;
    _currentBufferPointers: any[];
    _currentInstanceLocations: any[];
    _currentInstanceBuffers: any[];
    _vaoRecordInProgress: boolean;
    _mustWipeVertexAttributes: boolean;
    _nextFreeTextureSlots: any[];
    _maxSimultaneousTextures: number;
    _activeRequests: any[];
    _transformTextureUrl: any;
    hostInformation: {
        isMobile: boolean;
    };
    premultipliedAlpha: boolean;
    onBeforeTextureInitObservable: Observable;
    _isWebGPU: boolean;
    _snapshotRenderingMode: number;
    _viewportCached: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    _unpackFlipYCached: any;
    enableUnpackFlipYCached: boolean;
    _boundUniforms: {};
    _renderingCanvas: any;
    _audioContext: any;
    _audioDestination: any;
    _checkForMobile: () => void;
    _onContextLost: (evt: any) => void;
    _onContextRestored: () => void;
    _gl: any;
    _shaderPlatformName: string;
    _hardwareScalingLevel: number;
    _isStencilEnable: boolean;
    _shaderProcessor: WebGLShaderProcessor | WebGL2ShaderProcessor;
    _creationOptions: any;
    get description(): string;
    get name(): string;
    get version(): number;
    _getShaderProcessor(shaderLanguage: any): WebGLShaderProcessor | WebGL2ShaderProcessor;
    set useReverseDepthBuffer(arg: boolean);
    get useReverseDepthBuffer(): boolean;
    get frameId(): number;
    get supportsUniformBuffers(): boolean;
    get _shouldUseHighPrecisionShader(): boolean;
    get needPOTTextures(): boolean;
    get activeRenderLoops(): any[];
    set doNotHandleContextLost(arg: boolean);
    get doNotHandleContextLost(): boolean;
    get _supportsHardwareTextureRescaling(): boolean;
    set framebufferDimensionsObject(arg: any);
    _framebufferDimensionsObject: any;
    get currentViewport(): any;
    get emptyTexture(): void;
    _emptyTexture: void;
    get emptyTexture3D(): void;
    _emptyTexture3D: void;
    get emptyTexture2DArray(): void;
    _emptyTexture2DArray: void;
    get emptyCubeTexture(): void;
    _emptyCubeTexture: void;
    get isWebGPU(): boolean;
    get shaderPlatformName(): string;
    set snapshotRendering(arg: boolean);
    get snapshotRendering(): boolean;
    set snapshotRenderingMode(arg: number);
    get snapshotRenderingMode(): number;
    snapshotRenderingReset(): void;
    createCanvas(width: any, height: any): any;
    createCanvasImage(): HTMLImageElement;
    _restoreEngineAfterContextLost(initEngine: any): void;
    _sharedInit(canvas: any, doNotHandleTouchAction: any, audioEngine: any): void;
    _getShaderProcessingContext(shaderLanguage: any): any;
    _rebuildInternalTextures(): void;
    _rebuildRenderTargetWrappers(): void;
    _rebuildEffects(): void;
    areAllEffectsReady(): boolean;
    _rebuildBuffers(): void;
    _initGLContext(): void;
    _caps: {
        maxTexturesImageUnits: any;
        maxCombinedTexturesImageUnits: any;
        maxVertexTextureImageUnits: any;
        maxTextureSize: any;
        maxSamples: any;
        maxCubemapTextureSize: any;
        maxRenderTextureSize: any;
        maxVertexAttribs: any;
        maxVaryingVectors: any;
        maxFragmentUniformVectors: any;
        maxVertexUniformVectors: any;
        parallelShaderCompile: any;
        standardDerivatives: boolean;
        maxAnisotropy: number;
        astc: any;
        bptc: any;
        s3tc: any;
        s3tc_srgb: any;
        pvrtc: any;
        etc1: any;
        etc2: any;
        textureAnisotropicFilterExtension: any;
        uintIndices: boolean;
        fragmentDepthSupported: boolean;
        highPrecisionShaderSupported: boolean;
        timerQuery: any;
        supportOcclusionQuery: boolean;
        canUseTimestampForTimerQuery: boolean;
        drawBuffersExtension: boolean;
        maxMSAASamples: number;
        colorBufferFloat: boolean;
        textureFloat: boolean;
        textureHalfFloat: boolean;
        textureHalfFloatRender: boolean;
        textureFloatLinearFiltering: boolean;
        textureFloatRender: boolean;
        textureHalfFloatLinearFiltering: boolean;
        vertexArrayObject: boolean;
        instancedArrays: boolean;
        textureLOD: boolean;
        blendMinMax: boolean;
        multiview: any;
        oculusMultiview: any;
        depthTextureExtension: boolean;
        canUseGLInstanceID: boolean;
        canUseGLVertexID: boolean;
        supportComputeShaders: boolean;
        supportSRGBBuffers: boolean;
    };
    _glVersion: any;
    _glRenderer: any;
    _glVendor: any;
    _initFeatures(): void;
    _features: {
        forceBitmapOverHTMLImageElement: boolean;
        supportRenderAndCopyToLodForFloatTextures: boolean;
        supportDepthStencilTexture: boolean;
        supportShadowSamplers: boolean;
        uniformBufferHardCheckMatrix: boolean;
        allowTexturePrefiltering: boolean;
        trackUbosInFrame: boolean;
        checkUbosContentBeforeUpload: boolean;
        supportCSM: boolean;
        basisNeedsPOT: boolean;
        support3DTextures: boolean;
        needTypeSuffixInShaderConstants: boolean;
        supportMSAA: boolean;
        supportSSAO2: boolean;
        supportExtendedTextureFormats: boolean;
        supportSwitchCaseInShader: boolean;
        supportSyncTextureRead: boolean;
        needsInvertingBitmap: boolean;
        useUBOBindingCache: boolean;
        needShaderCodeInlining: boolean;
        needToAlwaysBindUniformBuffers: boolean;
        supportRenderPasses: boolean;
        _collectUbosUpdatedInFrame: boolean;
    };
    get webGLVersion(): number;
    getClassName(): string;
    get isStencilEnable(): boolean;
    _prepareWorkingCanvas(): void;
    _workingCanvas: any;
    _workingContext: any;
    resetTextureCache(): void;
    getInfo(): {
        vendor: any;
        renderer: any;
        version: any;
    };
    getGlInfo(): {
        vendor: any;
        renderer: any;
        version: any;
    };
    setHardwareScalingLevel(level: any): void;
    getHardwareScalingLevel(): number;
    getLoadedTexturesCache(): any[];
    getCaps(): {
        maxTexturesImageUnits: any;
        maxCombinedTexturesImageUnits: any;
        maxVertexTextureImageUnits: any;
        maxTextureSize: any;
        maxSamples: any;
        maxCubemapTextureSize: any;
        maxRenderTextureSize: any;
        maxVertexAttribs: any;
        maxVaryingVectors: any;
        maxFragmentUniformVectors: any;
        maxVertexUniformVectors: any;
        parallelShaderCompile: any;
        standardDerivatives: boolean;
        maxAnisotropy: number;
        astc: any;
        bptc: any;
        s3tc: any;
        s3tc_srgb: any;
        pvrtc: any;
        etc1: any;
        etc2: any;
        textureAnisotropicFilterExtension: any;
        uintIndices: boolean;
        fragmentDepthSupported: boolean;
        highPrecisionShaderSupported: boolean;
        timerQuery: any;
        supportOcclusionQuery: boolean;
        canUseTimestampForTimerQuery: boolean;
        drawBuffersExtension: boolean;
        maxMSAASamples: number;
        colorBufferFloat: boolean;
        textureFloat: boolean;
        textureHalfFloat: boolean;
        textureHalfFloatRender: boolean;
        textureFloatLinearFiltering: boolean;
        textureFloatRender: boolean;
        textureHalfFloatLinearFiltering: boolean;
        vertexArrayObject: boolean;
        instancedArrays: boolean;
        textureLOD: boolean;
        blendMinMax: boolean;
        multiview: any;
        oculusMultiview: any;
        depthTextureExtension: boolean;
        canUseGLInstanceID: boolean;
        canUseGLVertexID: boolean;
        supportComputeShaders: boolean;
        supportSRGBBuffers: boolean;
    };
    stopRenderLoop(renderFunction: any): void;
    _renderLoop(): void;
    _frameHandler: any;
    getRenderingCanvas(): any;
    getAudioContext(): any;
    getAudioDestination(): any;
    getHostWindow(): any;
    getRenderWidth(useScreen?: boolean): any;
    getRenderHeight(useScreen?: boolean): any;
    _queueNewFrame(bindedRenderFunction: any, requester: any): any;
    runRenderLoop(renderFunction: any): void;
    _boundRenderFunction: any;
    clear(color: any, backBuffer: any, depth: any, stencil?: boolean): void;
    _viewport(x: any, y: any, width: any, height: any): void;
    setViewport(viewport: any, requiredWidth: any, requiredHeight: any): void;
    _cachedViewport: any;
    beginFrame(): void;
    endFrame(): void;
    resize(forceSetSize?: boolean): void;
    setSize(width: any, height: any, forceSetSize?: boolean): boolean;
    bindFramebuffer(texture: any, faceIndex: number, requiredWidth: any, requiredHeight: any, forceFullscreenViewport: any, lodLevel?: number, layer?: number): void;
    _currentRenderTarget: any;
    setState(culling: any, zOffset: number, force: any, reverseSide: boolean, cullBackFaces: any, stencil: any, zOffsetUnits?: number): void;
    setZOffset(value: any): void;
    getZOffset(): any;
    setZOffsetUnits(value: any): void;
    getZOffsetUnits(): any;
    _bindUnboundFramebuffer(framebuffer: any): void;
    _currentFrameBufferIsDefaultFrameBuffer(): boolean;
    generateMipmaps(texture: any): void;
    unBindFramebuffer(texture: any, disableGenerateMipMaps: boolean, onBeforeUnbind: any): void;
    flushFramebuffer(): void;
    restoreDefaultFramebuffer(): void;
    _resetVertexBufferBinding(): void;
    _cachedVertexBuffers: any;
    createVertexBuffer(data: any): WebGLDataBuffer;
    _createVertexBuffer(data: any, usage: any): WebGLDataBuffer;
    createDynamicVertexBuffer(data: any): WebGLDataBuffer;
    _resetIndexBufferBinding(): void;
    _cachedIndexBuffer: any;
    createIndexBuffer(indices: any, updatable: any): WebGLDataBuffer;
    _normalizeIndexData(indices: any): any;
    bindArrayBuffer(buffer: any): void;
    bindUniformBlock(pipelineContext: any, blockName: any, index: any): void;
    bindIndexBuffer(buffer: any): void;
    bindBuffer(buffer: any, target: any): void;
    updateArrayBuffer(data: any): void;
    _vertexAttribPointer(buffer: any, indx: any, size: any, type: any, normalized: any, stride: any, offset: any): void;
    _bindIndexBufferWithCache(indexBuffer: any): void;
    _bindVertexBuffersAttributes(vertexBuffers: any, effect: any, overrideVertexBuffers: any): void;
    recordVertexArrayObject(vertexBuffers: any, indexBuffer: any, effect: any, overrideVertexBuffers: any): any;
    bindVertexArrayObject(vertexArrayObject: any, indexBuffer: any): void;
    _cachedVertexArrayObject: any;
    bindBuffersDirectly(vertexBuffer: any, indexBuffer: any, vertexDeclaration: any, vertexStrideSize: any, effect: any): void;
    _cachedEffectForVertexBuffers: any;
    _unbindVertexArrayObject(): void;
    bindBuffers(vertexBuffers: any, indexBuffer: any, effect: any, overrideVertexBuffers: any): void;
    unbindInstanceAttributes(): void;
    releaseVertexArrayObject(vao: any): void;
    _releaseBuffer(buffer: any): boolean;
    _deleteBuffer(buffer: any): void;
    updateAndBindInstancesBuffer(instancesBuffer: any, data: any, offsetLocations: any): void;
    bindInstancesBuffer(instancesBuffer: any, attributesInfo: any, computeStride?: boolean): void;
    disableInstanceAttributeByName(name: any): void;
    disableInstanceAttribute(attributeLocation: any): void;
    disableAttributeByIndex(attributeLocation: any): void;
    draw(useTriangles: any, indexStart: any, indexCount: any, instancesCount: any): void;
    drawPointClouds(verticesStart: any, verticesCount: any, instancesCount: any): void;
    drawUnIndexed(useTriangles: any, verticesStart: any, verticesCount: any, instancesCount: any): void;
    drawElementsType(fillMode: any, indexStart: any, indexCount: any, instancesCount: any): void;
    drawArraysType(fillMode: any, verticesStart: any, verticesCount: any, instancesCount: any): void;
    _drawMode(fillMode: any): any;
    _reportDrawCall(): void;
    _releaseEffect(effect: any): void;
    _deletePipelineContext(pipelineContext: any): void;
    _getGlobalDefines(defines: any): string;
    createEffect(baseName: any, attributesNamesOrOptions: any, uniformsNamesOrEngine: any, samplers: any, defines: any, fallbacks: any, onCompiled: any, onError: any, indexParameters: any, shaderLanguage?: any): any;
    _compileShader(source: any, type: any, defines: any, shaderVersion: any): any;
    _compileRawShader(source: any, type: any): any;
    _getShaderSource(shader: any): any;
    createRawShaderProgram(pipelineContext: any, vertexCode: any, fragmentCode: any, context: any, transformFeedbackVaryings?: any): any;
    createShaderProgram(pipelineContext: any, vertexCode: any, fragmentCode: any, defines: any, context: any, transformFeedbackVaryings?: any): any;
    inlineShaderCode(code: any): any;
    createPipelineContext(shaderProcessingContext: any): WebGLPipelineContext;
    createMaterialContext(): any;
    createDrawContext(): any;
    _createShaderProgram(pipelineContext: any, vertexShader: any, fragmentShader: any, context: any, transformFeedbackVaryings?: any): any;
    _finalizePipelineContext(pipelineContext: any): void;
    _preparePipelineContext(pipelineContext: any, vertexSourceCode: any, fragmentSourceCode: any, createAsRaw: any, rawVertexSourceCode: any, rawFragmentSourceCode: any, rebuildRebind: any, defines: any, transformFeedbackVaryings: any, key: any): void;
    _isRenderingStateCompiled(pipelineContext: any): boolean;
    _executeWhenRenderingStateIsCompiled(pipelineContext: any, action: any): void;
    getUniforms(pipelineContext: any, uniformsNames: any): any[];
    getAttributes(pipelineContext: any, attributesNames: any): any[];
    enableEffect(effect: any): void;
    _currentEffect: any;
    setInt(uniform: any, value: any): boolean;
    setInt2(uniform: any, x: any, y: any): boolean;
    setInt3(uniform: any, x: any, y: any, z: any): boolean;
    setInt4(uniform: any, x: any, y: any, z: any, w: any): boolean;
    setIntArray(uniform: any, array: any): boolean;
    setIntArray2(uniform: any, array: any): boolean;
    setIntArray3(uniform: any, array: any): boolean;
    setIntArray4(uniform: any, array: any): boolean;
    setArray(uniform: any, array: any): boolean;
    setArray2(uniform: any, array: any): boolean;
    setArray3(uniform: any, array: any): boolean;
    setArray4(uniform: any, array: any): boolean;
    setMatrices(uniform: any, matrices: any): boolean;
    setMatrix3x3(uniform: any, matrix: any): boolean;
    setMatrix2x2(uniform: any, matrix: any): boolean;
    setFloat(uniform: any, value: any): boolean;
    setFloat2(uniform: any, x: any, y: any): boolean;
    setFloat3(uniform: any, x: any, y: any, z: any): boolean;
    setFloat4(uniform: any, x: any, y: any, z: any, w: any): boolean;
    applyStates(): void;
    setColorWrite(enable: any): void;
    getColorWrite(): boolean;
    get depthCullingState(): DepthCullingState;
    get alphaState(): AlphaState;
    get stencilState(): StencilState;
    get stencilStateComposer(): StencilStateComposer;
    clearInternalTexturesCache(): void;
    wipeCaches(bruteForce: any): void;
    _currentProgram: any;
    _getSamplingParameters(samplingMode: any, generateMipMaps: any): {
        min: any;
        mag: any;
    };
    _createTexture(): any;
    _createHardwareTexture(): WebGLHardwareTexture;
    _createInternalTexture(size: any, options: any, delayGPUTextureCreation?: boolean, source?: any): InternalTexture;
    _getUseSRGBBuffer(useSRGBBuffer: any, noMipmap: any): any;
    _createTextureBase(url: any, noMipmap: any, invertY: any, scene: any, samplingMode: number, onLoad: any, onError: any, prepareTexture: any, prepareTextureProcessFunction: any, buffer: any, fallback: any, format: any, forcedExtension: any, mimeType: any, loaderOptions: any, useSRGBBuffer: any): any;
    createTexture(url: any, noMipmap: any, invertY: any, scene: any, samplingMode: number, onLoad: any, onError: any, buffer: any, fallback: any, format: any, forcedExtension: any, mimeType: any, loaderOptions: any, creationFlags: any, useSRGBBuffer: any): any;
    _rescaleTexture(source: any, destination: any, scene: any, internalFormat: any, onComplete: any): void;
    createRawTexture(data: any, width: any, height: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, type?: number): void;
    createRawCubeTexture(data: any, size: any, format: any, type: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any): void;
    createRawTexture3D(data: any, width: any, height: any, depth: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, textureType?: number): void;
    createRawTexture2DArray(data: any, width: any, height: any, depth: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, textureType?: number): void;
    _unpackFlipY(value: any): void;
    _getUnpackAlignement(): any;
    _getTextureTarget(texture: any): any;
    updateTextureSamplingMode(samplingMode: any, texture: any, generateMipMaps?: boolean): void;
    updateTextureDimensions(texture: any, width: any, height: any, depth?: number): void;
    updateTextureWrappingMode(texture: any, wrapU: any, wrapV?: any, wrapR?: any): void;
    _setupDepthStencilTexture(internalTexture: any, size: any, generateStencil: any, bilinearFiltering: any, comparisonFunction: any, samples?: number): void;
    _uploadCompressedDataToTextureDirectly(texture: any, internalFormat: any, width: any, height: any, data: any, faceIndex?: number, lod?: number): void;
    _uploadDataToTextureDirectly(texture: any, imageData: any, faceIndex: number, lod: number, babylonInternalFormat: any, useTextureWidthAndHeight?: boolean): void;
    updateTextureData(texture: any, imageData: any, xOffset: any, yOffset: any, width: any, height: any, faceIndex?: number, lod?: number): void;
    _uploadArrayBufferViewToTexture(texture: any, imageData: any, faceIndex?: number, lod?: number): void;
    _prepareWebGLTextureContinuation(texture: any, scene: any, noMipmap: any, isCompressed: any, samplingMode: any): void;
    _prepareWebGLTexture(texture: any, extension: any, scene: any, img: any, invertY: any, noMipmap: any, isCompressed: any, processFunction: any, samplingMode?: number): void;
    _setupFramebufferDepthAttachments(generateStencilBuffer: any, generateDepthBuffer: any, width: any, height: any, samples?: number): any;
    _createRenderBuffer(width: any, height: any, samples: any, internalFormat: any, msInternalFormat: any, attachment: any, unbindBuffer?: boolean): any;
    _releaseTexture(texture: any): void;
    _releaseRenderTargetWrapper(rtWrapper: any): void;
    _deleteTexture(texture: any): void;
    _setProgram(program: any): void;
    bindSamplers(effect: any): void;
    _activateCurrentTexture(): void;
    _bindTextureDirectly(target: any, texture: any, forTextureDataUpdate?: boolean, force?: boolean): boolean;
    _bindTexture(channel: any, texture: any, name: any): void;
    unbindAllTextures(): void;
    setTexture(channel: any, uniform: any, texture: any, name: any): void;
    _bindSamplerUniformToChannel(sourceSlot: any, destination: any): void;
    _getTextureWrapMode(mode: any): any;
    _setTexture(channel: any, texture: any, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean, name?: string): boolean;
    setTextureArray(channel: any, uniform: any, textures: any, name: any): void;
    _textureUnits: Int32Array;
    _setAnisotropicLevel(target: any, internalTexture: any, anisotropicFilteringLevel: any): void;
    _setTextureParameterFloat(target: any, parameter: any, value: any, texture: any): void;
    _setTextureParameterInteger(target: any, parameter: any, value: any, texture: any): void;
    unbindAllAttributes(): void;
    releaseEffects(): void;
    dispose(): void;
    attachContextLostEvent(callback: any): void;
    attachContextRestoredEvent(callback: any): void;
    getError(): any;
    _canRenderToFloatFramebuffer(): boolean;
    _canRenderToHalfFloatFramebuffer(): boolean;
    _canRenderToFramebuffer(type: any): boolean;
    _getWebGLTextureType(type: any): any;
    _getInternalFormat(format: any, useSRGBBuffer?: boolean): any;
    _getRGBABufferInternalSizedFormat(type: any, format: any, useSRGBBuffer?: boolean): any;
    _getRGBAMultiSampleBufferFormat(type: any): any;
    _loadFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any): void;
    readPixels(x: any, y: any, width: any, height: any, hasAlpha?: boolean, flushRenderer?: boolean): Promise<Uint8Array>;
    getHostDocument(): any;
    _readTexturePixelsSync(texture: any, width: any, height: any, faceIndex?: number, level?: number, buffer?: any, flushRenderer?: boolean, noDataConversion?: boolean): any;
    _readTexturePixels(texture: any, width: any, height: any, faceIndex?: number, level?: number, buffer?: any, flushRenderer?: boolean, noDataConversion?: boolean): Promise<any>;
}
export namespace ThinEngine {
    const _IsSupported: boolean;
    const _HasMajorPerformanceCaveat: boolean;
    const ExceptionList: {
        key: string;
        capture: string;
        captureConstraint: number;
        targets: string[];
    }[];
    const _TextureLoaders: any[];
    const CollisionsEpsilon: number;
}
export const ToGammaSpace: number;
export const ToLinearSpace: 2.2;
export class Tools {
    static set BaseUrl(arg: string);
    static get BaseUrl(): string;
    static set DefaultRetryStrategy(arg: (url: any, request: any, retryIndex: any) => number);
    static get DefaultRetryStrategy(): (url: any, request: any, retryIndex: any) => number;
    static set CorsBehavior(arg: string);
    static get CorsBehavior(): string;
    static set UseFallbackTexture(arg: boolean);
    static get UseFallbackTexture(): boolean;
    static set RegisteredExternalClasses(arg: {});
    static get RegisteredExternalClasses(): {};
    static set fallbackTexture(arg: string);
    static get fallbackTexture(): string;
    static FetchToRef(u: any, v: any, width: any, height: any, pixels: any, color: any): void;
    static Mix(a: any, b: any, alpha: any): number;
    static Instantiate(className: any): any;
    static Slice(data: any, start: any, end: any): any;
    static SliceToArray(data: any, start: any, end: any): any;
    static SetImmediate(action: any): void;
    static IsExponentOfTwo(value: any): boolean;
    static FloatRound(value: any): number;
    static GetFilename(path: any): any;
    static GetFolderPath(uri: any, returnUnchangedIfNoSlash?: boolean): any;
    static ToDegrees(angle: any): number;
    static ToRadians(angle: any): number;
    static MakeArray(obj: any, allowsNullUndefined: any): any[];
    static GetPointerPrefix(engine: any): string;
    static SetCorsBehavior(url: any, element: any): void;
    static CleanUrl(url: any): any;
    static set PreprocessUrl(arg: (url: any) => any);
    static get PreprocessUrl(): (url: any) => any;
    static LoadImage(input: any, onLoad: any, onError: any, offlineProvider: any, mimeType: any, imageBitmapOptions: any): HTMLImageElement;
    static LoadFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any): {
        onCompleteObservable: Observable;
        abort: () => void;
    };
    static LoadFileAsync(url: any, useArrayBuffer?: boolean): Promise<any>;
    static LoadScript(scriptUrl: any, onSuccess: any, onError: any, scriptId: any): void;
    static LoadScriptAsync(scriptUrl: any, scriptId: any): Promise<any>;
    static ReadFileAsDataURL(fileToLoad: any, callback: any, progressCallback: any): {
        onCompleteObservable: Observable;
        abort: () => void;
    };
    static ReadFile(file: any, onSuccess: any, onProgress: any, useArrayBuffer: any, onError: any): {
        onCompleteObservable: Observable;
        abort: () => void;
    };
    static FileAsURL(content: any): string;
    static Format(value: any, decimals?: number): any;
    static DeepCopy(source: any, destination: any, doNotCopyList: any, mustCopyList: any): void;
    static IsEmpty(obj: any): boolean;
    static RegisterTopRootEvents(windowElement: any, events: any): void;
    static UnregisterTopRootEvents(windowElement: any, events: any): void;
    static DumpFramebuffer(width: any, height: any, engine: any, successCallback: any, mimeType: string, fileName: any): Promise<void>;
    static DumpData(width: any, height: any, data: any, successCallback: any, mimeType: string, fileName: any, invertY: boolean, toArrayBuffer: boolean, quality: any): void;
    static DumpDataAsync(width: any, height: any, data: any, mimeType: string, fileName: any, invertY: boolean, toArrayBuffer: boolean, quality: any): Promise<any>;
    static ToBlob(canvas: any, successCallback: any, mimeType: string, quality: any): void;
    static EncodeScreenshotCanvasData(successCallback: any, mimeType: string, fileName: any, canvas: any, quality: any): void;
    static Download(blob: any, fileName: any): void;
    static BackCompatCameraNoPreventDefault(args: any): boolean;
    static CreateScreenshot(engine: any, camera: any, size: any, successCallback: any, mimeType?: string): void;
    static CreateScreenshotAsync(engine: any, camera: any, size: any, mimeType?: string): void;
    static CreateScreenshotUsingRenderTarget(engine: any, camera: any, size: any, successCallback: any, mimeType: string, samples: number, antialiasing: boolean, fileName: any): void;
    static CreateScreenshotUsingRenderTargetAsync(engine: any, camera: any, size: any, mimeType: string, samples: number, antialiasing: boolean, fileName: any): void;
    static RandomId(): string;
    static IsBase64(uri: any): boolean;
    static DecodeBase64(uri: any): ArrayBufferLike;
    static get errorsCount(): number;
    static Log(message: any): void;
    static Warn(message: any): void;
    static Error(message: any): void;
    static get LogCache(): string;
    static ClearLogCache(): void;
    static set LogLevels(arg: any);
    static set PerformanceLogLevel(arg: any);
    static _StartPerformanceCounterDisabled(counterName: any, condition: any): void;
    static _EndPerformanceCounterDisabled(counterName: any, condition: any): void;
    static _StartUserMark(counterName: any, condition?: boolean): void;
    static _EndUserMark(counterName: any, condition?: boolean): void;
    static _StartPerformanceConsole(counterName: any, condition?: boolean): void;
    static _EndPerformanceConsole(counterName: any, condition?: boolean): void;
    static get Now(): number;
    static GetClassName(object: any, isType?: boolean): any;
    static First(array: any, predicate: any): any;
    static getFullClassName(object: any, isType?: boolean): string;
    static DelayAsync(delay: any): Promise<any>;
    static IsSafari(): boolean;
}
export namespace Tools {
    export const UseCustomRequestHeaders: boolean;
    import CustomRequestHeaders = WebRequest.CustomRequestHeaders;
    export { CustomRequestHeaders };
    export const _tmpFloatArray: Float32Array;
    export { GetDOMTextContent };
    export function GetAbsoluteUrl(url: any): string;
    import NoneLogLevel_1 = Logger.NoneLogLevel;
    export { NoneLogLevel_1 as NoneLogLevel };
    import MessageLogLevel_1 = Logger.MessageLogLevel;
    export { MessageLogLevel_1 as MessageLogLevel };
    import WarningLogLevel_1 = Logger.WarningLogLevel;
    export { WarningLogLevel_1 as WarningLogLevel };
    import ErrorLogLevel_1 = Logger.ErrorLogLevel;
    export { ErrorLogLevel_1 as ErrorLogLevel };
    import AllLogLevel_1 = Logger.AllLogLevel;
    export { AllLogLevel_1 as AllLogLevel };
    export { IsWindowObjectExist };
    export const PerformanceNoneLogLevel: number;
    export const PerformanceUserMarkLogLevel: number;
    export const PerformanceConsoleLogLevel: number;
    import StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
    export { StartPerformanceCounter };
    import EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
    export { EndPerformanceCounter };
}
export class UniformBuffer {
    constructor(engine: any, data: any, dynamic: any, name: any);
    _valueCache: {};
    _engine: any;
    _noUBO: boolean;
    _dynamic: any;
    _name: any;
    _data: any;
    _uniformLocations: {};
    _uniformSizes: {};
    _uniformArraySizes: {};
    _uniformLocationPointer: number;
    _needSync: boolean;
    _buffers: any[];
    _bufferIndex: number;
    _createBufferOnWrite: boolean;
    _currentFrameId: number;
    updateMatrix3x3: (name: any, matrix: any) => void;
    updateMatrix2x2: (name: any, matrix: any) => void;
    updateFloat: (name: any, x: any) => void;
    updateFloat2: (name: any, x: any, y: any, suffix?: string) => void;
    updateFloat3: (name: any, x: any, y: any, z: any, suffix?: string) => void;
    updateFloat4: (name: any, x: any, y: any, z: any, w: any, suffix?: string) => void;
    updateFloatArray: (name: any, array: any) => void;
    updateArray: (name: any, array: any) => void;
    updateIntArray: (name: any, array: any) => void;
    updateMatrix: (name: any, mat: any) => void;
    updateMatrices: (name: any, mat: any) => void;
    updateVector3: (name: any, vector: any) => void;
    updateVector4: (name: any, vector: any) => void;
    updateColor3: (name: any, color: any, suffix?: string) => void;
    updateColor4: (name: any, color: any, alpha: any, suffix?: string) => void;
    updateDirectColor4: (name: any, color: any, suffix?: string) => void;
    updateInt: (name: any, x: any, suffix?: string) => void;
    updateInt2: (name: any, x: any, y: any, suffix?: string) => void;
    updateInt3: (name: any, x: any, y: any, z: any, suffix?: string) => void;
    updateInt4: (name: any, x: any, y: any, z: any, w: any, suffix?: string) => void;
    get useUbo(): boolean;
    get isSync(): boolean;
    isDynamic(): boolean;
    getData(): Float32Array;
    getBuffer(): any;
    _fillAlignment(size: any): void;
    addUniform(name: any, size: any, arraySize?: number): void;
    addMatrix(name: any, mat: any): void;
    addFloat2(name: any, x: any, y: any): void;
    addFloat3(name: any, x: any, y: any, z: any): void;
    addColor3(name: any, color: any): void;
    addColor4(name: any, color: any, alpha: any): void;
    addVector3(name: any, vector: any): void;
    addMatrix3x3(name: any): void;
    addMatrix2x2(name: any): void;
    create(): void;
    _bufferData: Float32Array;
    _rebuild(): void;
    _buffer: any;
    get _numBuffers(): number;
    get _indexBuffer(): number;
    get name(): any;
    _buffersEqual(buf1: any, buf2: any): boolean;
    _copyBuffer(src: any, dst: any): void;
    update(): void;
    _createNewBuffer(): void;
    _checkNewFrame(): void;
    updateUniform(uniformName: any, data: any, size: any): void;
    updateUniformArray(uniformName: any, data: any, size: any): void;
    _cacheMatrix(name: any, matrix: any): boolean;
    _updateMatrix3x3ForUniform(name: any, matrix: any): void;
    _updateMatrix3x3ForEffect(name: any, matrix: any): void;
    _updateMatrix2x2ForEffect(name: any, matrix: any): void;
    _updateMatrix2x2ForUniform(name: any, matrix: any): void;
    _updateFloatForEffect(name: any, x: any): void;
    _updateFloatForUniform(name: any, x: any): void;
    _updateFloat2ForEffect(name: any, x: any, y: any, suffix?: string): void;
    _updateFloat2ForUniform(name: any, x: any, y: any): void;
    _updateFloat3ForEffect(name: any, x: any, y: any, z: any, suffix?: string): void;
    _updateFloat3ForUniform(name: any, x: any, y: any, z: any): void;
    _updateFloat4ForEffect(name: any, x: any, y: any, z: any, w: any, suffix?: string): void;
    _updateFloat4ForUniform(name: any, x: any, y: any, z: any, w: any): void;
    _updateFloatArrayForEffect(name: any, array: any): void;
    _updateFloatArrayForUniform(name: any, array: any): void;
    _updateArrayForEffect(name: any, array: any): void;
    _updateArrayForUniform(name: any, array: any): void;
    _updateIntArrayForEffect(name: any, array: any): void;
    _updateIntArrayForUniform(name: any, array: any): void;
    _updateMatrixForEffect(name: any, mat: any): void;
    _updateMatrixForUniform(name: any, mat: any): void;
    _updateMatricesForEffect(name: any, mat: any): void;
    _updateMatricesForUniform(name: any, mat: any): void;
    _updateVector3ForEffect(name: any, vector: any): void;
    _updateVector3ForUniform(name: any, vector: any): void;
    _updateVector4ForEffect(name: any, vector: any): void;
    _updateVector4ForUniform(name: any, vector: any): void;
    _updateColor3ForEffect(name: any, color: any, suffix?: string): void;
    _updateColor3ForUniform(name: any, color: any): void;
    _updateColor4ForEffect(name: any, color: any, alpha: any, suffix?: string): void;
    _updateDirectColor4ForEffect(name: any, color: any, suffix?: string): void;
    _updateColor4ForUniform(name: any, color: any, alpha: any): void;
    _updateDirectColor4ForUniform(name: any, color: any): void;
    _updateIntForEffect(name: any, x: any, suffix?: string): void;
    _updateIntForUniform(name: any, x: any): void;
    _updateInt2ForEffect(name: any, x: any, y: any, suffix?: string): void;
    _updateInt2ForUniform(name: any, x: any, y: any): void;
    _updateInt3ForEffect(name: any, x: any, y: any, z: any, suffix?: string): void;
    _updateInt3ForUniform(name: any, x: any, y: any, z: any): void;
    _updateInt4ForEffect(name: any, x: any, y: any, z: any, w: any, suffix?: string): void;
    _updateInt4ForUniform(name: any, x: any, y: any, z: any, w: any): void;
    setTexture(name: any, texture: any): void;
    updateUniformDirectly(uniformName: any, data: any): void;
    bindToEffect(effect: any, name: any): void;
    _currentEffect: any;
    _currentEffectName: any;
    bindUniformBuffer(): void;
    unbindEffect(): void;
    dispose(): void;
}
export namespace UniformBuffer {
    const _updatedUbosInFrame: {};
    const _MAX_UNIFORM_SIZE: number;
    const _tempBuffer: Float32Array;
    const _tempBufferInt32View: Uint32Array;
}
export class VertexBuffer {
    static DeduceStride(kind: any): 2 | 3 | 4;
    static GetTypeByteLength(type: any): 1 | 2 | 4;
    static ForEach(data: any, byteOffset: any, byteStride: any, componentCount: any, componentType: any, count: any, normalized: any, callback: any): void;
    static _GetFloatValue(dataView: any, type: any, byteOffset: any, normalized: any): any;
    constructor(engine: any, data: any, kind: any, updatable: any, postponeInternalCreation: any, stride: any, instanced: any, offset: any, size: any, type: any, normalized?: boolean, useBytes?: boolean, divisor?: number, takeBufferOwnership?: boolean);
    _buffer: Buffer;
    _ownsBuffer: boolean;
    uniqueId: number;
    _kind: any;
    type: any;
    _size: any;
    byteStride: any;
    byteOffset: any;
    normalized: boolean;
    _instanced: any;
    _instanceDivisor: number;
    set instanceDivisor(arg: number);
    get instanceDivisor(): number;
    _computeHashCode(): void;
    hashCode: number;
    _rebuild(): void;
    getKind(): any;
    isUpdatable(): any;
    getData(): any;
    getFloatData(totalVertices: any, forceCopy: any): any;
    getBuffer(): DataBuffer;
    getStrideSize(): number;
    getOffset(): number;
    getSize(sizeInBytes?: boolean): any;
    getIsInstanced(): any;
    getInstanceDivisor(): number;
    create(data: any): void;
    update(data: any): void;
    updateDirectly(data: any, offset: any, useBytes?: boolean): void;
    dispose(): void;
    forEach(count: any, callback: any): void;
}
export namespace VertexBuffer {
    const _Counter_2: number;
    export { _Counter_2 as _Counter };
    export const BYTE: number;
    export const UNSIGNED_BYTE: number;
    export const SHORT: number;
    export const UNSIGNED_SHORT: number;
    export const INT: number;
    export const UNSIGNED_INT: number;
    export const FLOAT: number;
    export const PositionKind: string;
    export const NormalKind: string;
    export const TangentKind: string;
    export const UVKind: string;
    export const UV2Kind: string;
    export const UV3Kind: string;
    export const UV4Kind: string;
    export const UV5Kind: string;
    export const UV6Kind: string;
    export const ColorKind: string;
    export const MatricesIndicesKind: string;
    export const MatricesWeightsKind: string;
    export const MatricesIndicesExtraKind: string;
    export const MatricesWeightsExtraKind: string;
}
export var VertexFormat: any;
export class WebGL2ShaderProcessor {
    shaderLanguage: any;
    attributeProcessor(attribute: any): any;
    varyingProcessor(varying: any, isFragment: any): any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
}
export class WebGLDataBuffer extends DataBuffer {
    constructor(resource: any);
    _buffer: any;
}
export class WebGLHardwareTexture {
    constructor(existingTexture: any, context: any);
    _MSAARenderBuffer: any;
    _context: any;
    get underlyingResource(): any;
    setUsage(textureSource: any, generateMipMaps: any, isCube: any, width: any, height: any): void;
    set(hardwareTexture: any): void;
    _webGLTexture: any;
    reset(): void;
    release(): void;
}
export class WebGLPipelineContext {
    _valueCache: {};
    vertexCompilationError: any;
    fragmentCompilationError: any;
    programLinkError: any;
    programValidationError: any;
    get isAsync(): any;
    get isReady(): any;
    _handlesSpectorRebuildCallback(onCompiled: any): void;
    _fillEffectInformation(effect: any, uniformBuffersNames: any, uniformsNames: any, uniforms: any, samplerList: any, samplers: any, attributesNames: any, attributes: any): void;
    _uniforms: any;
    dispose(): void;
    _cacheMatrix(uniformName: any, matrix: any): boolean;
    _cacheFloat2(uniformName: any, x: any, y: any): boolean;
    _cacheFloat3(uniformName: any, x: any, y: any, z: any): boolean;
    _cacheFloat4(uniformName: any, x: any, y: any, z: any, w: any): boolean;
    setInt(uniformName: any, value: any): void;
    setInt2(uniformName: any, x: any, y: any): void;
    setInt3(uniformName: any, x: any, y: any, z: any): void;
    setInt4(uniformName: any, x: any, y: any, z: any, w: any): void;
    setIntArray(uniformName: any, array: any): void;
    setIntArray2(uniformName: any, array: any): void;
    setIntArray3(uniformName: any, array: any): void;
    setIntArray4(uniformName: any, array: any): void;
    setArray(uniformName: any, array: any): void;
    setArray2(uniformName: any, array: any): void;
    setArray3(uniformName: any, array: any): void;
    setArray4(uniformName: any, array: any): void;
    setMatrices(uniformName: any, matrices: any): void;
    setMatrix(uniformName: any, matrix: any): void;
    setMatrix3x3(uniformName: any, matrix: any): void;
    setMatrix2x2(uniformName: any, matrix: any): void;
    setFloat(uniformName: any, value: any): void;
    setVector2(uniformName: any, vector2: any): void;
    setFloat2(uniformName: any, x: any, y: any): void;
    setVector3(uniformName: any, vector3: any): void;
    setFloat3(uniformName: any, x: any, y: any, z: any): void;
    setVector4(uniformName: any, vector4: any): void;
    setFloat4(uniformName: any, x: any, y: any, z: any, w: any): void;
    setColor3(uniformName: any, color3: any): void;
    setColor4(uniformName: any, color3: any, alpha: any): void;
    setDirectColor4(uniformName: any, color4: any): void;
    _getVertexShaderCode(): any;
    _getFragmentShaderCode(): any;
}
export class WebGPUCacheBindGroups {
    static get Statistics(): {
        totalCreated: number;
        lastFrameCreated: number;
        lookupLastFrame: number;
        noLookupLastFrame: number;
    };
    constructor(device: any, cacheSampler: any, engine: any);
    disabled: boolean;
    _device: any;
    _cacheSampler: any;
    _engine: any;
    endFrame(): void;
    getBindGroups(webgpuPipelineContext: any, drawContext: any, materialContext: any): any;
}
export namespace WebGPUCacheBindGroups {
    const NumBindGroupsCreatedTotal: number;
    const NumBindGroupsCreatedLastFrame: number;
    const NumBindGroupsLookupLastFrame: number;
    const NumBindGroupsNoLookupLastFrame: number;
    const _Cache: WebGPUBindGroupCacheNode;
    const _NumBindGroupsCreatedCurrentFrame: number;
    const _NumBindGroupsLookupCurrentFrame: number;
    const _NumBindGroupsNoLookupCurrentFrame: number;
}
export class WebGPUCacheRenderPipeline {
    static _GetTopology(fillMode: any): any;
    static _GetAphaBlendOperation(operation: any): any;
    static _GetAphaBlendFactor(factor: any): any;
    static _GetCompareFunction(compareFunction: any): any;
    static _GetStencilOpFunction(operation: any): any;
    static _GetVertexInputDescriptorFormat(vertexBuffer: any): any;
    constructor(device: any, emptyVertexBuffer: any, useTextureStage: any);
    _device: any;
    _useTextureStage: any;
    _states: any[];
    _statesLength: number;
    _stateDirtyLowestIndex: number;
    _emptyVertexBuffer: any;
    _mrtFormats: any[];
    _parameter: {
        token: any;
        pipeline: any;
    };
    disabled: boolean;
    vertexBuffers: any[];
    _kMaxVertexBufferStride: any;
    reset(): void;
    _isDirty: any;
    _webgpuColorFormat: any[];
    get colorFormats(): any[];
    getRenderPipeline(fillMode: any, effect: any, sampleCount: any, textureState?: number): any;
    lastStateDirtyLowestIndex: number;
    endFrame(): void;
    setAlphaToCoverage(enabled: any): void;
    _alphaToCoverageEnabled: any;
    setFrontFace(frontFace: any): void;
    _frontFace: any;
    setCullEnabled(enabled: any): void;
    _cullEnabled: any;
    setCullFace(cullFace: any): void;
    _cullFace: any;
    setClampDepth(clampDepth: any): void;
    _clampDepth: any;
    resetDepthCullingState(): void;
    setDepthCullingState(cullEnabled: any, frontFace: any, cullFace: any, zOffset: any, zOffsetUnits: any, depthTestEnabled: any, depthWriteEnabled: any, depthCompare: any): void;
    _depthWriteEnabled: any;
    _depthTestEnabled: any;
    _depthCompare: number;
    setDepthBias(depthBias: any): void;
    _depthBias: any;
    setDepthBiasSlopeScale(depthBiasSlopeScale: any): void;
    _depthBiasSlopeScale: any;
    setColorFormat(format: any): void;
    _colorFormat: any;
    setMRTAttachments(attachments: any, textureArray: any): void;
    mrtAttachments: any;
    mrtTextureArray: any;
    _mrtAttachments1: any;
    _mrtAttachments2: number;
    setAlphaBlendEnabled(enabled: any): void;
    _alphaBlendEnabled: any;
    setAlphaBlendFactors(factors: any, operations: any): void;
    _alphaBlendFuncParams: any;
    _alphaBlendEqParams: any;
    setWriteMask(mask: any): void;
    _writeMask: any;
    setDepthStencilFormat(format: any): void;
    _webgpuDepthStencilFormat: any;
    _depthStencilFormat: any;
    setDepthTestEnabled(enabled: any): void;
    setDepthWriteEnabled(enabled: any): void;
    setDepthCompare(func: any): void;
    setStencilEnabled(enabled: any): void;
    _stencilEnabled: any;
    setStencilCompare(func: any): void;
    _stencilFrontCompare: number;
    setStencilDepthFailOp(op: any): void;
    _stencilFrontDepthFailOp: any;
    setStencilPassOp(op: any): void;
    _stencilFrontPassOp: any;
    setStencilFailOp(op: any): void;
    _stencilFrontFailOp: any;
    setStencilReadMask(mask: any): void;
    _stencilReadMask: any;
    setStencilWriteMask(mask: any): void;
    _stencilWriteMask: any;
    resetStencilState(): void;
    setStencilState(stencilEnabled: any, compare: any, depthFailOp: any, passOp: any, failOp: any, readMask: any, writeMask: any): void;
    setBuffers(vertexBuffers: any, indexBuffer: any, overrideVertexBuffers: any): void;
    _vertexBuffers: any;
    _overrideVertexBuffers: any;
    _indexBuffer: any;
    _getAphaBlendState(): {
        srcFactor: any;
        dstFactor: any;
        operation: any;
    };
    _getColorBlendState(): {
        srcFactor: any;
        dstFactor: any;
        operation: any;
    };
    _setShaderStage(id: any): void;
    _shaderId: any;
    _setRasterizationState(topology: any, sampleCount: any): void;
    _rasterizationState: any;
    _setColorStates(): void;
    _colorStates: any;
    _setDepthStencilState(): void;
    _depthStencilState: any;
    _setVertexState(effect: any): void;
    _setTextureState(textureState: any): void;
    _textureState: any;
    _createPipelineLayout(webgpuPipelineContext: any): any;
    _createPipelineLayoutWithTextureStage(webgpuPipelineContext: any): any;
    _getVertexInputDescriptor(effect: any, topology: any): {
        arrayStride: any;
        stepMode: any;
        attributes: any[];
    }[];
    _createRenderPipeline(effect: any, topology: any, sampleCount: any): any;
}
export namespace WebGPUCacheRenderPipeline {
    const NumCacheHitWithoutHash: number;
    const NumCacheHitWithHash: number;
    const NumCacheMiss: number;
    const NumPipelineCreationLastFrame: number;
    const _NumPipelineCreationCurrentFrame: number;
}
export class WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {
    static GetNodeCounts(): {
        nodeCount: number;
        pipelineCount: number;
    };
    static _GetPipelines(node: any, pipelines: any, curPath: any, curPathLen: any): void;
    static GetPipelines(): any[];
    _nodeStack: NodeState[];
    _getRenderPipeline(param: any): void;
    _setRenderPipeline(param: any): void;
}
export namespace WebGPUCacheRenderPipelineTree {
    const _Cache_1: NodeState;
    export { _Cache_1 as _Cache };
}
export class WebGPUCacheSampler {
    static GetSamplerHashCode(sampler: any): number;
    static _GetSamplerFilterDescriptor(sampler: any, anisotropy: any): {
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        anisotropyEnabled: boolean;
        lodMinClamp?: undefined;
        lodMaxClamp?: undefined;
    } | {
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        lodMinClamp: number;
        lodMaxClamp: number;
        anisotropyEnabled?: undefined;
    };
    static _GetWrappingMode(mode: any): any;
    static _GetSamplerWrappingDescriptor(sampler: any): {
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
    };
    static _GetSamplerDescriptor(sampler: any): {
        compare: any;
        maxAnisotropy: number;
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        anisotropyEnabled: boolean;
        lodMinClamp?: undefined;
        lodMaxClamp?: undefined;
    } | {
        compare: any;
        maxAnisotropy: number;
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        lodMinClamp: number;
        lodMaxClamp: number;
        anisotropyEnabled?: undefined;
    };
    constructor(device: any);
    _samplers: {};
    _device: any;
    disabled: boolean;
    getSampler(sampler: any, bypassCache?: boolean, hash?: number): any;
}
export class WebGPUDataBuffer extends DataBuffer {
    constructor(resource: any);
    _buffer: any;
}
export class WebGPUDrawContext {
    constructor(bufferManager: any);
    _bufferManager: any;
    uniqueId: number;
    _useInstancing: boolean;
    _currentInstanceCount: number;
    isDirty(materialContextUpdateId: any): boolean;
    resetIsDirty(materialContextUpdateId: any): void;
    _isDirty: boolean;
    materialContextUpdateId: any;
    set useInstancing(arg: boolean);
    get useInstancing(): boolean;
    indirectDrawBuffer: any;
    _indirectDrawData: Uint32Array;
    reset(): void;
    buffers: {};
    fastBundle: any;
    bindGroups: any;
    setBuffer(name: any, buffer: any): void;
    setIndirectData(indexOrVertexCount: any, instanceCount: any, firstIndexOrVertex: any): void;
    dispose(): void;
}
export namespace WebGPUDrawContext {
    const _Counter_3: number;
    export { _Counter_3 as _Counter };
}
export class WebGPUEngine extends Engine {
    static get IsSupportedAsync(): any;
    static CreateAsync(canvas: any, options?: {}): Promise<any>;
    constructor(canvas: any, options?: {});
    _uploadEncoderDescriptor: {
        label: string;
    };
    _renderEncoderDescriptor: {
        label: string;
    };
    _renderTargetEncoderDescriptor: {
        label: string;
    };
    _clearDepthValue: number;
    _clearReverseDepthValue: number;
    _clearStencilValue: number;
    _defaultSampleCount: number;
    _glslang: any;
    _tintWASM: WebGPUTintWASM;
    _compiledComputeEffects: {};
    _counters: {
        numEnableEffects: number;
        numEnableDrawWrapper: number;
        numBundleCreationNonCompatMode: number;
        numBundleReuseNonCompatMode: number;
    };
    countersLastFrame: {
        numEnableEffects: number;
        numEnableDrawWrapper: number;
        numBundleCreationNonCompatMode: number;
        numBundleReuseNonCompatMode: number;
    };
    numMaxUncapturedErrors: number;
    _commandBuffers: any[];
    _currentRenderPass: any;
    _mainRenderPassWrapper: WebGPURenderPassWrapper;
    _rttRenderPassWrapper: WebGPURenderPassWrapper;
    _pendingDebugCommands: any[];
    _onAfterUnbindFrameBufferObservable: Observable;
    _currentOverrideVertexBuffers: any;
    _currentIndexBuffer: any;
    __colorWrite: boolean;
    _forceEnableEffect: boolean;
    dbgShowShaderCode: boolean;
    dbgSanityChecks: boolean;
    dbgVerboseLogsForFirstFrames: boolean;
    dbgVerboseLogsNumFrames: number;
    dbgLogIfNotDrawWrapper: boolean;
    dbgShowEmptyEnableEffectCalls: boolean;
    _viewportsCurrent: {
        x: number;
        y: number;
        w: number;
        h: number;
    }[];
    _scissorsCurrent: {
        x: number;
        y: number;
        w: number;
        h: number;
    }[];
    _scissorCached: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    _stencilRefsCurrent: number[];
    _blendColorsCurrent: any[][];
    _canvas: any;
    _options: {};
    _mainPassSampleCount: number;
    _shaderProcessorWGSL: WebGPUShaderProcessorWGSL;
    set disableCacheSamplers(arg: boolean);
    get disableCacheSamplers(): boolean;
    set disableCacheRenderPipelines(arg: boolean);
    get disableCacheRenderPipelines(): boolean;
    set disableCacheBindGroups(arg: boolean);
    get disableCacheBindGroups(): boolean;
    get supportedExtensions(): any[];
    get enabledExtensions(): any[];
    get currentSampleCount(): any;
    initAsync(glslangOptions: any, twgslOptions: any): any;
    _adapter: any;
    _adapterSupportedExtensions: any[];
    _device: any;
    _deviceEnabledExtensions: any[];
    _bufferManager: WebGPUBufferManager;
    _textureHelper: WebGPUTextureHelper;
    _cacheSampler: WebGPUCacheSampler;
    _cacheBindGroups: WebGPUCacheBindGroups;
    _timestampQuery: WebGPUTimestampQuery;
    _occlusionQuery: WebGPUOcclusionQuery;
    _bundleList: WebGPUBundleList;
    _bundleListRenderTarget: WebGPUBundleList;
    _snapshotRendering: WebGPUSnapshotRendering;
    _ubInvertY: WebGPUDataBuffer;
    _ubDontInvertY: WebGPUDataBuffer;
    _count: number;
    _uploadEncoder: any;
    _renderEncoder: any;
    _renderTargetEncoder: any;
    _emptyVertexBuffer: VertexBuffer;
    _cacheRenderPipeline: WebGPUCacheRenderPipelineTree;
    _clearQuad: WebGPUClearQuad;
    _defaultDrawContext: WebGPUDrawContext;
    _currentDrawContext: any;
    _defaultMaterialContext: WebGPUMaterialContext;
    _currentMaterialContext: any;
    _initGlslang(glslangOptions: any): any;
    _initializeLimits(): void;
    _initializeContextAndSwapChain(): void;
    _context: any;
    _colorFormat: any;
    _initializeMainAttachments(): void;
    _mainTextureExtends: {
        width: any;
        height: any;
        depthOrArrayLayers: number;
    };
    _mainTexture: any;
    _depthTexture: any;
    _configureContext(width: any, height: any): void;
    _resetCurrentViewport(index: any): void;
    _mustUpdateViewport(renderPass: any): boolean;
    _applyViewport(renderPass: any): void;
    _resetCurrentScissor(index: any): void;
    _mustUpdateScissor(renderPass: any): boolean;
    _applyScissor(renderPass: any): void;
    _scissorIsActive(): boolean;
    _resetCurrentStencilRef(index: any): void;
    _mustUpdateStencilRef(renderPass: any): boolean;
    _applyStencilRef(renderPass: any): void;
    _resetCurrentColorBlend(index: any): void;
    _mustUpdateBlendColor(renderPass: any): boolean;
    _applyBlendColor(renderPass: any): void;
    _clearFullQuad(clearColor: any, clearDepth: any, clearStencil: any): void;
    _createBuffer(data: any, creationFlags: any): WebGPUDataBuffer;
    _compileRawShaderToSpirV(source: any, type: any): any;
    _compileShaderToSpirV(source: any, type: any, defines: any, shaderVersion: any): any;
    _getWGSLShader(source: any, type: any, defines: any, shaderVersion: any): any;
    _createPipelineStageDescriptor(vertexShader: any, fragmentShader: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _compileRawPipelineStageDescriptor(vertexCode: any, fragmentCode: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _compilePipelineStageDescriptor(vertexCode: any, fragmentCode: any, defines: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _setInternalTexture(name: any, texture: any, baseName: any, textureIndex?: number): void;
    _generateMipmaps(texture: any, commandEncoder: any): void;
    _startRenderTargetRenderPass(rtWrapper: any, setClearStates: any, clearColor: any, clearDepth: any, clearStencil: any): void;
    _mrtAttachments: any;
    _endRenderTargetRenderPass(): void;
    _getCurrentRenderPass(): any;
    _getCurrentRenderPassIndex(): 1 | -1 | 0;
    _startMainRenderPass(setClearStates: any, clearColor: any, clearDepth: any, clearStencil: any): void;
    _swapChainTexture: any;
    _endMainRenderPass(): void;
    _setColorFormat(wrapper: any): void;
    _setDepthTextureFormat(wrapper: any): void;
    _depthTextureFormat: any;
    _applyRenderPassChanges(renderPass: any, bundleList: any): void;
    _draw(drawType: any, fillMode: any, start: any, count: any, instancesCount: any): void;
}
export namespace WebGPUEngine {
    namespace _glslangDefaultOptions {
        const jsPath: string;
        const wasmPath: string;
    }
    const UseTWGSL: boolean;
}
export class WebGPUTintWASM {
    _twgsl: any;
    initTwgsl(twgslOptions: any): Promise<void>;
    convertSpirV2WGSL(code: any): any;
}
export namespace WebGPUTintWASM {
    namespace _twgslDefaultOptions {
        const jsPath_1: string;
        export { jsPath_1 as jsPath };
        const wasmPath_1: string;
        export { wasmPath_1 as wasmPath };
    }
}
export class WebRequest {
    _xhr: any;
    _injectCustomRequestHeaders(): void;
    set onprogress(arg: any);
    get onprogress(): any;
    get readyState(): any;
    get status(): any;
    get statusText(): any;
    get response(): any;
    get responseURL(): any;
    get responseText(): any;
    set responseType(arg: any);
    get responseType(): any;
    set timeout(arg: any);
    get timeout(): any;
    addEventListener(type: any, listener: any, options: any): void;
    removeEventListener(type: any, listener: any, options: any): void;
    abort(): void;
    send(body: any): void;
    open(method: any, url: any): any;
    setRequestHeader(name: any, value: any): void;
    getResponseHeader(name: any): any;
}
export namespace WebRequest {
    const CustomRequestHeaders_1: {};
    export { CustomRequestHeaders_1 as CustomRequestHeaders };
    export const CustomRequestModifiers: any[];
}
declare class BaseError extends Error {
}
declare namespace BaseError {
    function _setPrototypeOf(o: any, proto: object): any;
}
declare class WebGLShaderProcessor {
    shaderLanguage: any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
}
declare class WebGPUBindGroupCacheNode {
    values: {};
}
declare class NodeState {
    values: {};
    count(): number[];
}
declare class WebGPURenderPassWrapper {
    colorAttachmentGPUTextures: any[];
    reset(fullReset?: boolean): void;
    renderPass: any;
    renderPassDescriptor: any;
    colorAttachmentViewDescriptor: any;
    depthAttachmentViewDescriptor: any;
    depthTextureFormat: any;
}
declare class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {
    constructor(...args: any[]);
    uniformRegexp: RegExp;
    textureRegexp: RegExp;
    noPrecision: boolean;
    _getArraySize(name: any, uniformType: any, preProcessors: any): any[];
    initializeShaders(processingContext: any): void;
    webgpuProcessingContext: any;
    _attributesWGSL: any[];
    _attributesDeclWGSL: any[];
    _attributeNamesWGSL: any[];
    _varyingsWGSL: any[];
    _varyingsDeclWGSL: any[];
    _varyingNamesWGSL: any[];
    preProcessShaderCode(code: any, isFragment: any): string;
    varyingProcessor(varying: any, isFragment: any, preProcessors: any, processingContext: any): any;
    attributeProcessor(attribute: any, preProcessors: any, processingContext: any): any;
    uniformProcessor(uniform: any, isFragment: any, preProcessors: any, processingContext: any): any;
    textureProcessor(texture: any, isFragment: any, preProcessors: any, processingContext: any): any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
    finalizeShaders(vertexCode: any, fragmentCode: any, processingContext: any): {
        vertexCode: any;
        fragmentCode: any;
    };
    _generateLeftOverUBOCode(name: any, uniformBufferDescription: any): string;
    _processSamplers(code: any, isVertex: any): any;
    _processCustomBuffers(code: any, isVertex: any): any;
}
declare class WebGPUBufferManager {
    static _IsGPUBuffer(buffer: any): boolean;
    constructor(device: any);
    _deferredReleaseBuffers: any[];
    _device: any;
    createRawBuffer(viewOrSize: any, flags: any, mappedAtCreation?: boolean): any;
    createBuffer(viewOrSize: any, flags: any): WebGPUDataBuffer;
    setRawData(buffer: any, dstByteOffset: any, src: any, srcByteOffset: any, byteLength: any): void;
    setSubData(dataBuffer: any, dstByteOffset: any, src: any, srcByteOffset?: number, byteLength?: number): void;
    _GetHalfFloatAsFloatRGBAArrayBuffer(dataLength: any, arrayBuffer: any, destArray: any): any;
    readDataFromBuffer(gpuBuffer: any, size: any, width: any, height: any, bytesPerRow: any, bytesPerRowAligned: any, type?: number, offset?: number, buffer?: any, destroyBuffer?: boolean, noDataConversion?: boolean): Promise<any>;
    releaseBuffer(buffer: any): boolean;
    destroyDeferredBuffers(): void;
}
declare class WebGPUTextureHelper {
    static ComputeNumMipmapLevels(width: any, height: any): number;
    static _GetTextureTypeFromFormat(format: any): number;
    static _GetBlockInformationFromFormat(format: any): {
        width: number;
        height: number;
        length: number;
    };
    static _IsHardwareTexture(texture: any): boolean;
    static _IsInternalTexture(texture: any): boolean;
    static GetCompareFunction(compareFunction: any): any;
    static IsImageBitmap(imageBitmap: any): boolean;
    static IsImageBitmapArray(imageBitmap: any): boolean;
    static IsCompressedFormat(format: any): boolean;
    static GetWebGPUTextureFormat(type: any, format: any, useSRGBBuffer?: boolean): any;
    static GetNumChannelsFromWebGPUTextureFormat(format: any): 1 | 2 | 3 | 4;
    constructor(device: any, glslang: any, tintWASM: any, bufferManager: any);
    _pipelines: {};
    _compiledShaders: any[];
    _deferredReleaseTextures: any[];
    _device: any;
    _glslang: any;
    _tintWASM: any;
    _bufferManager: any;
    _mipmapSampler: any;
    _getPipeline(format: any, type: any, params: any): any;
    setCommandEncoder(encoder: any): void;
    _commandEncoderForCreation: any;
    invertYPreMultiplyAlpha(gpuOrHdwTexture: any, width: any, height: any, format: any, invertY: boolean, premultiplyAlpha: boolean, faceIndex: number, mipLevel: number, layers: number, commandEncoder: any, allowGPUOptimization: any): void;
    copyWithInvertY(srcTextureView: any, format: any, renderPassDescriptor: any, commandEncoder: any): void;
    createTexture(imageBitmap: any, hasMipmaps: boolean, generateMipmaps: boolean, invertY: boolean, premultiplyAlpha: boolean, is3D: boolean, format: any, sampleCount: number, commandEncoder: any, usage?: number, additionalUsages?: number): any;
    createCubeTexture(imageBitmaps: any, hasMipmaps: boolean, generateMipmaps: boolean, invertY: boolean, premultiplyAlpha: boolean, format: any, sampleCount: number, commandEncoder: any, usage?: number, additionalUsages?: number): any;
    generateCubeMipmaps(gpuTexture: any, format: any, mipLevelCount: any, commandEncoder: any): void;
    generateMipmaps(gpuOrHdwTexture: any, format: any, mipLevelCount: any, faceIndex: number, commandEncoder: any): void;
    createGPUTextureForInternalTexture(texture: any, width: any, height: any, depth: any, creationFlags: any): any;
    createMSAATexture(texture: any, samples: any): void;
    updateCubeTextures(imageBitmaps: any, gpuTexture: any, width: any, height: any, format: any, invertY: boolean, premultiplyAlpha: boolean, offsetX: number, offsetY: number, commandEncoder: any): void;
    updateTexture(imageBitmap: any, texture: any, width: any, height: any, layers: any, format: any, faceIndex: number, mipLevel: number, invertY: boolean, premultiplyAlpha: boolean, offsetX: number, offsetY: number, commandEncoder: any, allowGPUOptimization: any): void;
    readPixels(texture: any, x: any, y: any, width: any, height: any, format: any, faceIndex?: number, mipLevel?: number, buffer?: any, noDataConversion?: boolean): any;
    releaseTexture(texture: any): void;
    destroyDeferredTextures(): void;
}
declare class WebGPUTimestampQuery {
    constructor(device: any, bufferManager: any);
    _enabled: boolean;
    _gpuFrameTimeCounter: PerfCounter;
    _measureDurationState: number;
    _device: any;
    _bufferManager: any;
    get gpuFrameTimeCounter(): PerfCounter;
    set enable(arg: boolean);
    get enable(): boolean;
    _measureDuration: WebGPUDurationMeasure;
    startFrame(commandEncoder: any): void;
    endFrame(commandEncoder: any): void;
}
declare class WebGPUOcclusionQuery {
    constructor(engine: any, device: any, bufferManager: any, startCount?: number, incrementCount?: number);
    _availableIndices: any[];
    _engine: any;
    _device: any;
    _bufferManager: any;
    _frameLastBuffer: number;
    _currentTotalIndices: number;
    _countIncrement: number;
    get querySet(): any;
    get hasQueries(): boolean;
    get canBeginQuery(): boolean;
    createQuery(): any;
    deleteQuery(index: any): void;
    isQueryResultAvailable(index: any): boolean;
    getQueryResult(index: any): number;
    _retrieveQueryBuffer(): void;
    _lastBuffer: BigUint64Array;
    _allocateNewIndices(numIndices: any): void;
    _querySet: WebGPUQuerySet;
    _delayQuerySetDispose(): void;
    dispose(): void;
}
declare class WebGPUBundleList {
    constructor(device: any);
    numDrawCalls: number;
    _device: any;
    _list: any[];
    _listLength: number;
    addBundle(bundle: any): void;
    _currentBundleList: any[];
    _currentItemIsBundle: boolean;
    _finishBundle(): void;
    _bundleEncoder: any;
    addItem(item: any): void;
    getBundleEncoder(colorFormats: any, depthStencilFormat: any, sampleCount: any): any;
    close(): void;
    run(renderPass: any): void;
    reset(): void;
    clone(): WebGPUBundleList;
}
declare class WebGPUSnapshotRendering {
    constructor(engine: any, renderingMode: any, bundleList: any, bundleListRenderTarget: any);
    _record: boolean;
    _play: boolean;
    _mainPassBundleList: any[];
    _enabled: boolean;
    _engine: any;
    _mode: any;
    _bundleList: any;
    _bundleListRenderTarget: any;
    set enabled(arg: boolean);
    get enabled(): boolean;
    get play(): boolean;
    get record(): boolean;
    _modeSaved: any;
    set mode(arg: any);
    get mode(): any;
    endMainRenderPass(): void;
    endRenderTargetPass(currentRenderPass: any, gpuWrapper: any): boolean;
    endFrame(mainRenderPass: any): void;
    reset(): void;
}
declare class WebGPUClearQuad {
    constructor(device: any, engine: any, emptyVertexBuffer: any);
    _bindGroups: {};
    _bundleCache: {};
    _device: any;
    _engine: any;
    _cacheRenderPipeline: WebGPUCacheRenderPipelineTree;
    _effect: any;
    setDepthStencilFormat(format: any): void;
    _depthTextureFormat: any;
    setColorFormat(format: any): void;
    setMRTAttachments(attachments: any, textureArray: any): void;
    clear(renderPass: any, clearColor: any, clearDepth: any, clearStencil: any, sampleCount?: number): any;
}
declare class WebGPUMaterialContext {
    uniqueId: number;
    updateId: number;
    get forceBindGroupCreation(): boolean;
    get hasFloatTextures(): boolean;
    reset(): void;
    samplers: {};
    textures: {};
    isDirty: boolean;
    _numFloatTextures: number;
    _numExternalTextures: number;
    setSampler(name: any, sampler: any): void;
    setTexture(name: any, texture: any): void;
}
declare namespace WebGPUMaterialContext {
    const _Counter_4: number;
    export { _Counter_4 as _Counter };
}
declare class WebGPUShaderProcessor {
    shaderLanguage: any;
    _addUniformToLeftOverUBO(name: any, uniformType: any, preProcessors: any): void;
    _buildLeftOverUBO(): any;
    _collectBindingNames(): void;
    _preCreateBindGroupEntries(): void;
    _addTextureBindingDescription(name: any, textureInfo: any, textureIndex: any, dimension: any, format: any, isVertex: any): void;
    _addSamplerBindingDescription(name: any, samplerInfo: any, isVertex: any): void;
    _addBufferBindingDescription(name: any, uniformBufferInfo: any, bufferType: any, isVertex: any): void;
    _injectStartingAndEndingCode(code: any, mainFuncDecl: any, startingCode: any, endingCode: any): any;
}
declare namespace WebGPUShaderProcessor {
    const AutoSamplerSuffix: string;
    const LeftOvertUBOName: string;
    const InternalsUBOName: string;
    namespace UniformSizes {
        const bool: number;
        const int: number;
        const float: number;
        const vec2: number;
        const ivec2: number;
        const vec3: number;
        const ivec3: number;
        const vec4: number;
        const ivec4: number;
        const mat2: number;
        const mat3: number;
        const mat4: number;
        const i32: number;
        const u32: number;
        const f32: number;
        const mat2x2: number;
        const mat3x3: number;
        const mat4x4: number;
    }
    namespace _SamplerFunctionByWebGLSamplerType {
        const sampler2D: string;
        const sampler2DArray: string;
        const sampler2DShadow: string;
        const sampler2DArrayShadow: string;
        const samplerCube: string;
        const sampler3D: string;
    }
    namespace _TextureTypeByWebGLSamplerType {
        const sampler2D_1: string;
        export { sampler2D_1 as sampler2D };
        const sampler2DArray_1: string;
        export { sampler2DArray_1 as sampler2DArray };
        const sampler2DShadow_1: string;
        export { sampler2DShadow_1 as sampler2DShadow };
        const sampler2DArrayShadow_1: string;
        export { sampler2DArrayShadow_1 as sampler2DArrayShadow };
        const samplerCube_1: string;
        export { samplerCube_1 as samplerCube };
        export const samplerCubeArray: string;
        const sampler3D_1: string;
        export { sampler3D_1 as sampler3D };
    }
    namespace _GpuTextureViewDimensionByWebGPUTextureType {
        const textureCube: any;
        const textureCubeArray: any;
        const texture2D: any;
        const texture2DArray: any;
        const texture3D: any;
    }
    namespace _SamplerTypeByWebGLSamplerType {
        const sampler2DShadow_2: string;
        export { sampler2DShadow_2 as sampler2DShadow };
        const sampler2DArrayShadow_2: string;
        export { sampler2DArrayShadow_2 as sampler2DArrayShadow };
    }
    namespace _IsComparisonSamplerByWebGPUSamplerType {
        const samplerShadow: boolean;
        const samplerArrayShadow: boolean;
        const sampler: boolean;
    }
}
declare class WebGPUDurationMeasure {
    constructor(device: any, bufferManager: any);
    _querySet: WebGPUQuerySet;
    start(encoder: any): void;
    stop(encoder: any): Promise<number>;
    dispose(): void;
}
declare class WebGPUQuerySet {
    constructor(count: any, type: any, device: any, bufferManager: any, canUseMultipleBuffers?: boolean);
    _dstBuffers: any[];
    _device: any;
    _bufferManager: any;
    _count: any;
    _canUseMultipleBuffers: boolean;
    _querySet: any;
    _queryBuffer: any;
    get querySet(): any;
    _getBuffer(firstQuery: any, queryCount: any): any;
    readValues(firstQuery?: number, queryCount?: number): Promise<BigUint64Array>;
    readValue(firstQuery?: number): Promise<number>;
    readTwoValuesAndSubtract(firstQuery?: number): Promise<number>;
    dispose(): void;
}
export {};
