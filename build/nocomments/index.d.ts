export class WebGPUEngine extends Engine {
    static get IsSupportedAsync(): any;
    static CreateAsync(canvas: any, options?: {}): Promise<any>;
    constructor(canvas: any, options?: {});
    _uploadEncoderDescriptor: {
        label: string;
    };
    _renderEncoderDescriptor: {
        label: string;
    };
    _renderTargetEncoderDescriptor: {
        label: string;
    };
    _clearDepthValue: number;
    _clearReverseDepthValue: number;
    _clearStencilValue: number;
    _defaultSampleCount: number;
    _glslang: any;
    _tintWASM: WebGPUTintWASM;
    _compiledComputeEffects: {};
    _counters: {
        numEnableEffects: number;
        numEnableDrawWrapper: number;
        numBundleCreationNonCompatMode: number;
        numBundleReuseNonCompatMode: number;
    };
    countersLastFrame: {
        numEnableEffects: number;
        numEnableDrawWrapper: number;
        numBundleCreationNonCompatMode: number;
        numBundleReuseNonCompatMode: number;
    };
    numMaxUncapturedErrors: number;
    _commandBuffers: any[];
    _currentRenderPass: any;
    _mainRenderPassWrapper: WebGPURenderPassWrapper;
    _rttRenderPassWrapper: WebGPURenderPassWrapper;
    _pendingDebugCommands: any[];
    _onAfterUnbindFrameBufferObservable: Observable;
    _currentOverrideVertexBuffers: any;
    _currentIndexBuffer: any;
    __colorWrite: boolean;
    _forceEnableEffect: boolean;
    dbgShowShaderCode: boolean;
    dbgSanityChecks: boolean;
    dbgVerboseLogsForFirstFrames: boolean;
    dbgVerboseLogsNumFrames: number;
    dbgLogIfNotDrawWrapper: boolean;
    dbgShowEmptyEnableEffectCalls: boolean;
    _viewportsCurrent: {
        x: number;
        y: number;
        w: number;
        h: number;
    }[];
    _scissorsCurrent: {
        x: number;
        y: number;
        w: number;
        h: number;
    }[];
    _scissorCached: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    _stencilRefsCurrent: number[];
    _blendColorsCurrent: any[][];
    _canvas: any;
    _options: {};
    _mainPassSampleCount: number;
    _shaderProcessorWGSL: WebGPUShaderProcessorWGSL;
    set disableCacheSamplers(arg: boolean);
    get disableCacheSamplers(): boolean;
    set disableCacheRenderPipelines(arg: boolean);
    get disableCacheRenderPipelines(): boolean;
    set disableCacheBindGroups(arg: boolean);
    get disableCacheBindGroups(): boolean;
    get supportedExtensions(): any[];
    get enabledExtensions(): any[];
    get currentSampleCount(): any;
    initAsync(glslangOptions: any, twgslOptions: any): any;
    _adapter: any;
    _adapterSupportedExtensions: any[];
    _device: any;
    _deviceEnabledExtensions: any[];
    _bufferManager: WebGPUBufferManager;
    _textureHelper: WebGPUTextureHelper;
    _cacheSampler: WebGPUCacheSampler;
    _cacheBindGroups: WebGPUCacheBindGroups;
    _timestampQuery: WebGPUTimestampQuery;
    _occlusionQuery: WebGPUOcclusionQuery;
    _bundleList: WebGPUBundleList;
    _bundleListRenderTarget: WebGPUBundleList;
    _snapshotRendering: WebGPUSnapshotRendering;
    _ubInvertY: WebGPUDataBuffer;
    _ubDontInvertY: WebGPUDataBuffer;
    _count: number;
    _uploadEncoder: any;
    _renderEncoder: any;
    _renderTargetEncoder: any;
    _emptyVertexBuffer: VertexBuffer;
    _cacheRenderPipeline: WebGPUCacheRenderPipelineTree;
    _clearQuad: WebGPUClearQuad;
    _defaultDrawContext: WebGPUDrawContext;
    _currentDrawContext: any;
    _defaultMaterialContext: WebGPUMaterialContext;
    _currentMaterialContext: any;
    _initGlslang(glslangOptions: any): any;
    _initializeLimits(): void;
    _initializeContextAndSwapChain(): void;
    _context: any;
    _colorFormat: any;
    _initializeMainAttachments(): void;
    _mainTextureExtends: {
        width: any;
        height: any;
        depthOrArrayLayers: number;
    };
    _mainTexture: any;
    _depthTexture: any;
    _configureContext(width: any, height: any): void;
    _resetCurrentViewport(index: any): void;
    _mustUpdateViewport(renderPass: any): boolean;
    _applyViewport(renderPass: any): void;
    _resetCurrentScissor(index: any): void;
    _mustUpdateScissor(renderPass: any): boolean;
    _applyScissor(renderPass: any): void;
    _scissorIsActive(): boolean;
    _resetCurrentStencilRef(index: any): void;
    _mustUpdateStencilRef(renderPass: any): boolean;
    _applyStencilRef(renderPass: any): void;
    _resetCurrentColorBlend(index: any): void;
    _mustUpdateBlendColor(renderPass: any): boolean;
    _applyBlendColor(renderPass: any): void;
    _clearFullQuad(clearColor: any, clearDepth: any, clearStencil: any): void;
    _createBuffer(data: any, creationFlags: any): WebGPUDataBuffer;
    _compileRawShaderToSpirV(source: any, type: any): any;
    _compileShaderToSpirV(source: any, type: any, defines: any, shaderVersion: any): any;
    _getWGSLShader(source: any, type: any, defines: any, shaderVersion: any): any;
    _createPipelineStageDescriptor(vertexShader: any, fragmentShader: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _compileRawPipelineStageDescriptor(vertexCode: any, fragmentCode: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _compilePipelineStageDescriptor(vertexCode: any, fragmentCode: any, defines: any, shaderLanguage: any): {
        vertexStage: {
            module: any;
            entryPoint: string;
        };
        fragmentStage: {
            module: any;
            entryPoint: string;
        };
    };
    _setInternalTexture(name: any, texture: any, baseName: any, textureIndex?: number): void;
    _generateMipmaps(texture: any, commandEncoder: any): void;
    _startRenderTargetRenderPass(rtWrapper: any, setClearStates: any, clearColor: any, clearDepth: any, clearStencil: any): void;
    _mrtAttachments: any;
    _endRenderTargetRenderPass(): void;
    _getCurrentRenderPass(): any;
    _getCurrentRenderPassIndex(): 1 | -1 | 0;
    _startMainRenderPass(setClearStates: any, clearColor: any, clearDepth: any, clearStencil: any): void;
    _swapChainTexture: any;
    _endMainRenderPass(): void;
    _setColorFormat(wrapper: any): void;
    _setDepthTextureFormat(wrapper: any): void;
    _depthTextureFormat: any;
    _applyRenderPassChanges(renderPass: any, bundleList: any): void;
    _draw(drawType: any, fillMode: any, start: any, count: any, instancesCount: any): void;
}
export namespace WebGPUEngine {
    namespace _glslangDefaultOptions {
        const jsPath: string;
        const wasmPath: string;
    }
    const UseTWGSL: boolean;
}
declare class Engine extends ThinEngine {
    static get Instances(): any[];
    static get LastCreatedEngine(): any;
    static get LastCreatedScene(): any;
    static MarkAllMaterialsAsDirty(flag: any, predicate: any): void;
    static DefaultLoadingScreenFactory(canvas: any): void;
    static _RequestPointerlock(element: any): void;
    static _ExitPointerlock(): void;
    static _RequestFullscreen(element: any): void;
    static _ExitFullscreen(): void;
    constructor(canvasOrContext: any, antialias: any, options: any, adaptToDeviceRatio?: boolean);
    enableOfflineSupport: boolean;
    disableManifestCheck: boolean;
    scenes: any[];
    _virtualScenes: any[];
    onNewSceneAddedObservable: Observable;
    postProcesses: any[];
    isPointerLock: boolean;
    onResizeObservable: Observable;
    onCanvasBlurObservable: Observable;
    onCanvasFocusObservable: Observable;
    onCanvasPointerOutObservable: Observable;
    onBeginFrameObservable: Observable;
    customAnimationFrameRequester: any;
    onEndFrameObservable: Observable;
    onBeforeShaderCompilationObservable: Observable;
    onAfterShaderCompilationObservable: Observable;
    _deterministicLockstep: boolean;
    _lockstepMaxSteps: any;
    _timeStep: any;
    _fps: number;
    _deltaTime: number;
    _drawCalls: PerfCounter;
    canvasTabIndex: number;
    disablePerformanceMonitorInBackground: boolean;
    _performanceMonitor: PerformanceMonitor;
    _compatibilityMode: boolean;
    currentRenderPassId: number;
    _renderPassNames: string[];
    _onFullscreenChange: () => void;
    _onPointerLockChange: () => void;
    createImageBitmap(image: any, options: any): Promise<ImageBitmap>;
    resizeImageBitmap(image: any, bufferWidth: any, bufferHeight: any): any;
    get performanceMonitor(): PerformanceMonitor;
    set compatibilityMode(arg: boolean);
    get compatibilityMode(): boolean;
    getInputElement(): any;
    _onCanvasFocus: () => void;
    _onCanvasBlur: () => void;
    _onBlur: () => void;
    _onFocus: () => void;
    _onCanvasPointerOut: (ev: any) => void;
    getAspectRatio(viewportOwner: any, useScreen?: boolean): number;
    getScreenAspectRatio(): number;
    getRenderingCanvasClientRect(): any;
    getInputElementClientRect(): any;
    isDeterministicLockStep(): boolean;
    getLockstepMaxSteps(): any;
    getTimeStep(): number;
    generateMipMapsForCubemap(texture: any, unbind?: boolean): void;
    getDepthBuffer(): any;
    setDepthBuffer(enable: any): void;
    getDepthWrite(): any;
    setDepthWrite(enable: any): void;
    getStencilBuffer(): any;
    setStencilBuffer(enable: any): void;
    getStencilMask(): any;
    setStencilMask(mask: any): void;
    getStencilFunction(): any;
    getStencilFunctionReference(): any;
    getStencilFunctionMask(): any;
    setStencilFunction(stencilFunc: any): void;
    setStencilFunctionReference(reference: any): void;
    setStencilFunctionMask(mask: any): void;
    getStencilOperationFail(): any;
    getStencilOperationDepthFail(): any;
    getStencilOperationPass(): any;
    setStencilOperationFail(operation: any): void;
    setStencilOperationDepthFail(operation: any): void;
    setStencilOperationPass(operation: any): void;
    setDitheringState(value: any): void;
    setRasterizerState(value: any): void;
    getDepthFunction(): any;
    setDepthFunction(depthFunc: any): void;
    setDepthFunctionToGreater(): void;
    setDepthFunctionToGreaterOrEqual(): void;
    setDepthFunctionToLess(): void;
    setDepthFunctionToLessOrEqual(): void;
    cacheStencilState(): void;
    _cachedStencilBuffer: any;
    _cachedStencilFunction: any;
    _cachedStencilMask: any;
    _cachedStencilOperationPass: any;
    _cachedStencilOperationFail: any;
    _cachedStencilOperationDepthFail: any;
    _cachedStencilReference: any;
    restoreStencilState(): void;
    setDirectViewport(x: any, y: any, width: any, height: any): any;
    scissorClear(x: any, y: any, width: any, height: any, clearColor: any): void;
    enableScissor(x: any, y: any, width: any, height: any): void;
    disableScissor(): void;
    initWebVR(): void;
    _prepareVRComponent(): void;
    _connectVREvents(canvas: any, document: any): void;
    _submitVRFrame(): void;
    disableVR(): void;
    isVRPresenting(): boolean;
    _requestVRFrame(): void;
    _loadFileAsync(url: any, offlineProvider: any, useArrayBuffer: any): Promise<any>;
    getVertexShaderSource(program: any): any;
    getFragmentShaderSource(program: any): any;
    setDepthStencilTexture(channel: any, uniform: any, texture: any, name: any): void;
    setTextureFromPostProcess(channel: any, postProcess: any, name: any): void;
    setTextureFromPostProcessOutput(channel: any, postProcess: any, name: any): void;
    _renderFrame(): void;
    _renderViews(): boolean;
    switchFullscreen(requestPointerLock: any): void;
    enterFullscreen(requestPointerLock: any): void;
    _pointerLockRequested: any;
    exitFullscreen(): void;
    enterPointerlock(): void;
    exitPointerlock(): void;
    getRenderPassNames(): string[];
    getCurrentRenderPassName(): string;
    createRenderPassId(name: any): number;
    releaseRenderPassId(id: any): void;
    _rescalePostProcess: any;
    getFps(): number;
    getDeltaTime(): number;
    _measureFps(): void;
    _uploadImageToTexture(texture: any, image: any, faceIndex?: number, lod?: number): void;
    updateTextureComparisonFunction(texture: any, comparisonFunction: any): void;
    createInstancesBuffer(capacity: any): WebGLDataBuffer;
    deleteInstancesBuffer(buffer: any): void;
    _clientWaitAsync(sync: any, flags?: number, interval_ms?: number): Promise<any>;
    _readPixelsAsync(x: any, y: any, w: any, h: any, format: any, type: any, outputBuffer: any): Promise<any>;
    _disableTouchAction(): void;
    displayLoadingUI(): void;
    hideLoadingUI(): void;
    set loadingScreen(arg: any);
    get loadingScreen(): any;
    _loadingScreen: any;
    set loadingUIText(arg: any);
    set loadingUIBackgroundColor(arg: any);
    createVideoElement(constraints: any): HTMLVideoElement;
    getFontOffset(font: any): {
        ascent: number;
        height: number;
        descent: number;
    };
}
declare namespace Engine {
    import ALPHA_DISABLE = Constants.ALPHA_DISABLE;
    export { ALPHA_DISABLE };
    import ALPHA_ADD = Constants.ALPHA_ADD;
    export { ALPHA_ADD };
    import ALPHA_COMBINE = Constants.ALPHA_COMBINE;
    export { ALPHA_COMBINE };
    import ALPHA_SUBTRACT = Constants.ALPHA_SUBTRACT;
    export { ALPHA_SUBTRACT };
    import ALPHA_MULTIPLY = Constants.ALPHA_MULTIPLY;
    export { ALPHA_MULTIPLY };
    import ALPHA_MAXIMIZED = Constants.ALPHA_MAXIMIZED;
    export { ALPHA_MAXIMIZED };
    import ALPHA_ONEONE = Constants.ALPHA_ONEONE;
    export { ALPHA_ONEONE };
    import ALPHA_PREMULTIPLIED = Constants.ALPHA_PREMULTIPLIED;
    export { ALPHA_PREMULTIPLIED };
    import ALPHA_PREMULTIPLIED_PORTERDUFF = Constants.ALPHA_PREMULTIPLIED_PORTERDUFF;
    export { ALPHA_PREMULTIPLIED_PORTERDUFF };
    import ALPHA_INTERPOLATE = Constants.ALPHA_INTERPOLATE;
    export { ALPHA_INTERPOLATE };
    import ALPHA_SCREENMODE = Constants.ALPHA_SCREENMODE;
    export { ALPHA_SCREENMODE };
    import DELAYLOADSTATE_NONE = Constants.DELAYLOADSTATE_NONE;
    export { DELAYLOADSTATE_NONE };
    import DELAYLOADSTATE_LOADED = Constants.DELAYLOADSTATE_LOADED;
    export { DELAYLOADSTATE_LOADED };
    import DELAYLOADSTATE_LOADING = Constants.DELAYLOADSTATE_LOADING;
    export { DELAYLOADSTATE_LOADING };
    import DELAYLOADSTATE_NOTLOADED = Constants.DELAYLOADSTATE_NOTLOADED;
    export { DELAYLOADSTATE_NOTLOADED };
    import NEVER = Constants.NEVER;
    export { NEVER };
    import ALWAYS = Constants.ALWAYS;
    export { ALWAYS };
    import LESS = Constants.LESS;
    export { LESS };
    import EQUAL = Constants.EQUAL;
    export { EQUAL };
    import LEQUAL = Constants.LEQUAL;
    export { LEQUAL };
    import GREATER = Constants.GREATER;
    export { GREATER };
    import GEQUAL = Constants.GEQUAL;
    export { GEQUAL };
    import NOTEQUAL = Constants.NOTEQUAL;
    export { NOTEQUAL };
    import KEEP = Constants.KEEP;
    export { KEEP };
    import REPLACE = Constants.REPLACE;
    export { REPLACE };
    import INCR = Constants.INCR;
    export { INCR };
    import DECR = Constants.DECR;
    export { DECR };
    import INVERT = Constants.INVERT;
    export { INVERT };
    import INCR_WRAP = Constants.INCR_WRAP;
    export { INCR_WRAP };
    import DECR_WRAP = Constants.DECR_WRAP;
    export { DECR_WRAP };
    import TEXTURE_CLAMP_ADDRESSMODE = Constants.TEXTURE_CLAMP_ADDRESSMODE;
    export { TEXTURE_CLAMP_ADDRESSMODE };
    import TEXTURE_WRAP_ADDRESSMODE = Constants.TEXTURE_WRAP_ADDRESSMODE;
    export { TEXTURE_WRAP_ADDRESSMODE };
    import TEXTURE_MIRROR_ADDRESSMODE = Constants.TEXTURE_MIRROR_ADDRESSMODE;
    export { TEXTURE_MIRROR_ADDRESSMODE };
    import TEXTUREFORMAT_ALPHA = Constants.TEXTUREFORMAT_ALPHA;
    export { TEXTUREFORMAT_ALPHA };
    import TEXTUREFORMAT_LUMINANCE = Constants.TEXTUREFORMAT_LUMINANCE;
    export { TEXTUREFORMAT_LUMINANCE };
    import TEXTUREFORMAT_LUMINANCE_ALPHA = Constants.TEXTUREFORMAT_LUMINANCE_ALPHA;
    export { TEXTUREFORMAT_LUMINANCE_ALPHA };
    import TEXTUREFORMAT_RGB = Constants.TEXTUREFORMAT_RGB;
    export { TEXTUREFORMAT_RGB };
    import TEXTUREFORMAT_RGBA = Constants.TEXTUREFORMAT_RGBA;
    export { TEXTUREFORMAT_RGBA };
    import TEXTUREFORMAT_RED = Constants.TEXTUREFORMAT_RED;
    export { TEXTUREFORMAT_RED };
    import TEXTUREFORMAT_R = Constants.TEXTUREFORMAT_R;
    export { TEXTUREFORMAT_R };
    import TEXTUREFORMAT_RG = Constants.TEXTUREFORMAT_RG;
    export { TEXTUREFORMAT_RG };
    import TEXTUREFORMAT_RED_INTEGER = Constants.TEXTUREFORMAT_RED_INTEGER;
    export { TEXTUREFORMAT_RED_INTEGER };
    import TEXTUREFORMAT_R_INTEGER = Constants.TEXTUREFORMAT_R_INTEGER;
    export { TEXTUREFORMAT_R_INTEGER };
    import TEXTUREFORMAT_RG_INTEGER = Constants.TEXTUREFORMAT_RG_INTEGER;
    export { TEXTUREFORMAT_RG_INTEGER };
    import TEXTUREFORMAT_RGB_INTEGER = Constants.TEXTUREFORMAT_RGB_INTEGER;
    export { TEXTUREFORMAT_RGB_INTEGER };
    import TEXTUREFORMAT_RGBA_INTEGER = Constants.TEXTUREFORMAT_RGBA_INTEGER;
    export { TEXTUREFORMAT_RGBA_INTEGER };
    import TEXTURETYPE_UNSIGNED_BYTE = Constants.TEXTURETYPE_UNSIGNED_BYTE;
    export { TEXTURETYPE_UNSIGNED_BYTE };
    import TEXTURETYPE_UNSIGNED_INT = Constants.TEXTURETYPE_UNSIGNED_INT;
    export { TEXTURETYPE_UNSIGNED_INT };
    import TEXTURETYPE_FLOAT = Constants.TEXTURETYPE_FLOAT;
    export { TEXTURETYPE_FLOAT };
    import TEXTURETYPE_HALF_FLOAT = Constants.TEXTURETYPE_HALF_FLOAT;
    export { TEXTURETYPE_HALF_FLOAT };
    import TEXTURETYPE_BYTE = Constants.TEXTURETYPE_BYTE;
    export { TEXTURETYPE_BYTE };
    import TEXTURETYPE_SHORT = Constants.TEXTURETYPE_SHORT;
    export { TEXTURETYPE_SHORT };
    import TEXTURETYPE_UNSIGNED_SHORT = Constants.TEXTURETYPE_UNSIGNED_SHORT;
    export { TEXTURETYPE_UNSIGNED_SHORT };
    import TEXTURETYPE_INT = Constants.TEXTURETYPE_INT;
    export { TEXTURETYPE_INT };
    import TEXTURETYPE_UNSIGNED_INTEGER = Constants.TEXTURETYPE_UNSIGNED_INTEGER;
    export { TEXTURETYPE_UNSIGNED_INTEGER };
    import TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4;
    export { TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 };
    import TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 };
    import TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_6_5 };
    import TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV;
    export { TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV };
    import TEXTURETYPE_UNSIGNED_INT_24_8 = Constants.TEXTURETYPE_UNSIGNED_INT_24_8;
    export { TEXTURETYPE_UNSIGNED_INT_24_8 };
    import TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV;
    export { TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV };
    import TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV;
    export { TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV };
    import TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV;
    export { TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV };
    import TEXTURE_NEAREST_SAMPLINGMODE = Constants.TEXTURE_NEAREST_SAMPLINGMODE;
    export { TEXTURE_NEAREST_SAMPLINGMODE };
    import TEXTURE_BILINEAR_SAMPLINGMODE = Constants.TEXTURE_BILINEAR_SAMPLINGMODE;
    export { TEXTURE_BILINEAR_SAMPLINGMODE };
    import TEXTURE_TRILINEAR_SAMPLINGMODE = Constants.TEXTURE_TRILINEAR_SAMPLINGMODE;
    export { TEXTURE_TRILINEAR_SAMPLINGMODE };
    import TEXTURE_NEAREST_NEAREST_MIPLINEAR = Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR;
    export { TEXTURE_NEAREST_NEAREST_MIPLINEAR };
    import TEXTURE_LINEAR_LINEAR_MIPNEAREST = Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST;
    export { TEXTURE_LINEAR_LINEAR_MIPNEAREST };
    import TEXTURE_LINEAR_LINEAR_MIPLINEAR = Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR;
    export { TEXTURE_LINEAR_LINEAR_MIPLINEAR };
    import TEXTURE_NEAREST_NEAREST_MIPNEAREST = Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST;
    export { TEXTURE_NEAREST_NEAREST_MIPNEAREST };
    import TEXTURE_NEAREST_LINEAR_MIPNEAREST = Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST;
    export { TEXTURE_NEAREST_LINEAR_MIPNEAREST };
    import TEXTURE_NEAREST_LINEAR_MIPLINEAR = Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR;
    export { TEXTURE_NEAREST_LINEAR_MIPLINEAR };
    import TEXTURE_NEAREST_LINEAR = Constants.TEXTURE_NEAREST_LINEAR;
    export { TEXTURE_NEAREST_LINEAR };
    import TEXTURE_NEAREST_NEAREST = Constants.TEXTURE_NEAREST_NEAREST;
    export { TEXTURE_NEAREST_NEAREST };
    import TEXTURE_LINEAR_NEAREST_MIPNEAREST = Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST;
    export { TEXTURE_LINEAR_NEAREST_MIPNEAREST };
    import TEXTURE_LINEAR_NEAREST_MIPLINEAR = Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR;
    export { TEXTURE_LINEAR_NEAREST_MIPLINEAR };
    import TEXTURE_LINEAR_LINEAR = Constants.TEXTURE_LINEAR_LINEAR;
    export { TEXTURE_LINEAR_LINEAR };
    import TEXTURE_LINEAR_NEAREST = Constants.TEXTURE_LINEAR_NEAREST;
    export { TEXTURE_LINEAR_NEAREST };
    import TEXTURE_EXPLICIT_MODE = Constants.TEXTURE_EXPLICIT_MODE;
    export { TEXTURE_EXPLICIT_MODE };
    import TEXTURE_SPHERICAL_MODE = Constants.TEXTURE_SPHERICAL_MODE;
    export { TEXTURE_SPHERICAL_MODE };
    import TEXTURE_PLANAR_MODE = Constants.TEXTURE_PLANAR_MODE;
    export { TEXTURE_PLANAR_MODE };
    import TEXTURE_CUBIC_MODE = Constants.TEXTURE_CUBIC_MODE;
    export { TEXTURE_CUBIC_MODE };
    import TEXTURE_PROJECTION_MODE = Constants.TEXTURE_PROJECTION_MODE;
    export { TEXTURE_PROJECTION_MODE };
    import TEXTURE_SKYBOX_MODE = Constants.TEXTURE_SKYBOX_MODE;
    export { TEXTURE_SKYBOX_MODE };
    import TEXTURE_INVCUBIC_MODE = Constants.TEXTURE_INVCUBIC_MODE;
    export { TEXTURE_INVCUBIC_MODE };
    import TEXTURE_EQUIRECTANGULAR_MODE = Constants.TEXTURE_EQUIRECTANGULAR_MODE;
    export { TEXTURE_EQUIRECTANGULAR_MODE };
    import TEXTURE_FIXED_EQUIRECTANGULAR_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MODE };
    import TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE };
    import SCALEMODE_FLOOR = Constants.SCALEMODE_FLOOR;
    export { SCALEMODE_FLOOR };
    import SCALEMODE_NEAREST = Constants.SCALEMODE_NEAREST;
    export { SCALEMODE_NEAREST };
    import SCALEMODE_CEILING = Constants.SCALEMODE_CEILING;
    export { SCALEMODE_CEILING };
    export const _RescalePostProcessFactory: any;
    export const _RenderPassIdCounter: number;
}
declare class WebGPUTintWASM {
    _twgsl: any;
    initTwgsl(twgslOptions: any): Promise<void>;
    convertSpirV2WGSL(code: any): any;
}
declare namespace WebGPUTintWASM {
    namespace _twgslDefaultOptions {
        const jsPath_1: string;
        export { jsPath_1 as jsPath };
        const wasmPath_1: string;
        export { wasmPath_1 as wasmPath };
    }
}
declare class WebGPURenderPassWrapper {
    colorAttachmentGPUTextures: any[];
    reset(fullReset?: boolean): void;
    renderPass: any;
    renderPassDescriptor: any;
    colorAttachmentViewDescriptor: any;
    depthAttachmentViewDescriptor: any;
    depthTextureFormat: any;
}
declare class Observable {
    static FromPromise(promise: any, onErrorObservable: any): Observable;
    constructor(onObserverAdded: any);
    _observers: any[];
    _eventState: EventState;
    _onObserverAdded: any;
    get observers(): any[];
    add(callback: any, mask?: number, insertFirst?: boolean, scope?: any, unregisterOnFirstCall?: boolean): Observer;
    addOnce(callback: any): Observer;
    remove(observer: any): boolean;
    removeCallback(callback: any, scope: any): boolean;
    _deferUnregister(observer: any): void;
    _remove(observer: any): boolean;
    makeObserverTopPriority(observer: any): void;
    makeObserverBottomPriority(observer: any): void;
    notifyObservers(eventData: any, mask: number, target: any, currentTarget: any, userInfo: any): boolean;
    notifyObserversWithPromise(eventData: any, mask: number, target: any, currentTarget: any, userInfo: any): Promise<T>;
    notifyObserver(observer: any, eventData: any, mask?: number): void;
    hasObservers(): boolean;
    clear(): void;
    clone(): Observable;
    hasSpecificMask(mask?: number): boolean;
}
declare class WebGPUShaderProcessorWGSL extends WebGPUShaderProcessor {
    constructor(...args: any[]);
    uniformRegexp: RegExp;
    textureRegexp: RegExp;
    noPrecision: boolean;
    _getArraySize(name: any, uniformType: any, preProcessors: any): any[];
    initializeShaders(processingContext: any): void;
    webgpuProcessingContext: any;
    _attributesWGSL: any[];
    _attributesDeclWGSL: any[];
    _attributeNamesWGSL: any[];
    _varyingsWGSL: any[];
    _varyingsDeclWGSL: any[];
    _varyingNamesWGSL: any[];
    preProcessShaderCode(code: any, isFragment: any): string;
    varyingProcessor(varying: any, isFragment: any, preProcessors: any, processingContext: any): any;
    attributeProcessor(attribute: any, preProcessors: any, processingContext: any): any;
    uniformProcessor(uniform: any, isFragment: any, preProcessors: any, processingContext: any): any;
    textureProcessor(texture: any, isFragment: any, preProcessors: any, processingContext: any): any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
    finalizeShaders(vertexCode: any, fragmentCode: any, processingContext: any): {
        vertexCode: any;
        fragmentCode: any;
    };
    _generateLeftOverUBOCode(name: any, uniformBufferDescription: any): string;
    _processSamplers(code: any, isVertex: any): any;
    _processCustomBuffers(code: any, isVertex: any): any;
}
declare class WebGPUBufferManager {
    static _IsGPUBuffer(buffer: any): boolean;
    constructor(device: any);
    _deferredReleaseBuffers: any[];
    _device: any;
    createRawBuffer(viewOrSize: any, flags: any, mappedAtCreation?: boolean): any;
    createBuffer(viewOrSize: any, flags: any): WebGPUDataBuffer;
    setRawData(buffer: any, dstByteOffset: any, src: any, srcByteOffset: any, byteLength: any): void;
    setSubData(dataBuffer: any, dstByteOffset: any, src: any, srcByteOffset?: number, byteLength?: number): void;
    _GetHalfFloatAsFloatRGBAArrayBuffer(dataLength: any, arrayBuffer: any, destArray: any): any;
    readDataFromBuffer(gpuBuffer: any, size: any, width: any, height: any, bytesPerRow: any, bytesPerRowAligned: any, type?: number, offset?: number, buffer?: any, destroyBuffer?: boolean, noDataConversion?: boolean): Promise<any>;
    releaseBuffer(buffer: any): boolean;
    destroyDeferredBuffers(): void;
}
declare class WebGPUTextureHelper {
    static ComputeNumMipmapLevels(width: any, height: any): number;
    static _GetTextureTypeFromFormat(format: any): number;
    static _GetBlockInformationFromFormat(format: any): {
        width: number;
        height: number;
        length: number;
    };
    static _IsHardwareTexture(texture: any): boolean;
    static _IsInternalTexture(texture: any): boolean;
    static GetCompareFunction(compareFunction: any): any;
    static IsImageBitmap(imageBitmap: any): boolean;
    static IsImageBitmapArray(imageBitmap: any): boolean;
    static IsCompressedFormat(format: any): boolean;
    static GetWebGPUTextureFormat(type: any, format: any, useSRGBBuffer?: boolean): any;
    static GetNumChannelsFromWebGPUTextureFormat(format: any): 1 | 2 | 3 | 4;
    constructor(device: any, glslang: any, tintWASM: any, bufferManager: any);
    _pipelines: {};
    _compiledShaders: any[];
    _deferredReleaseTextures: any[];
    _device: any;
    _glslang: any;
    _tintWASM: any;
    _bufferManager: any;
    _mipmapSampler: any;
    _getPipeline(format: any, type: any, params: any): any;
    setCommandEncoder(encoder: any): void;
    _commandEncoderForCreation: any;
    invertYPreMultiplyAlpha(gpuOrHdwTexture: any, width: any, height: any, format: any, invertY: boolean, premultiplyAlpha: boolean, faceIndex: number, mipLevel: number, layers: number, commandEncoder: any, allowGPUOptimization: any): void;
    copyWithInvertY(srcTextureView: any, format: any, renderPassDescriptor: any, commandEncoder: any): void;
    createTexture(imageBitmap: any, hasMipmaps: boolean, generateMipmaps: boolean, invertY: boolean, premultiplyAlpha: boolean, is3D: boolean, format: any, sampleCount: number, commandEncoder: any, usage?: number, additionalUsages?: number): any;
    createCubeTexture(imageBitmaps: any, hasMipmaps: boolean, generateMipmaps: boolean, invertY: boolean, premultiplyAlpha: boolean, format: any, sampleCount: number, commandEncoder: any, usage?: number, additionalUsages?: number): any;
    generateCubeMipmaps(gpuTexture: any, format: any, mipLevelCount: any, commandEncoder: any): void;
    generateMipmaps(gpuOrHdwTexture: any, format: any, mipLevelCount: any, faceIndex: number, commandEncoder: any): void;
    createGPUTextureForInternalTexture(texture: any, width: any, height: any, depth: any, creationFlags: any): any;
    createMSAATexture(texture: any, samples: any): void;
    updateCubeTextures(imageBitmaps: any, gpuTexture: any, width: any, height: any, format: any, invertY: boolean, premultiplyAlpha: boolean, offsetX: number, offsetY: number, commandEncoder: any): void;
    updateTexture(imageBitmap: any, texture: any, width: any, height: any, layers: any, format: any, faceIndex: number, mipLevel: number, invertY: boolean, premultiplyAlpha: boolean, offsetX: number, offsetY: number, commandEncoder: any, allowGPUOptimization: any): void;
    readPixels(texture: any, x: any, y: any, width: any, height: any, format: any, faceIndex?: number, mipLevel?: number, buffer?: any, noDataConversion?: boolean): any;
    releaseTexture(texture: any): void;
    destroyDeferredTextures(): void;
}
declare class WebGPUCacheSampler {
    static GetSamplerHashCode(sampler: any): number;
    static _GetSamplerFilterDescriptor(sampler: any, anisotropy: any): {
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        anisotropyEnabled: boolean;
        lodMinClamp?: undefined;
        lodMaxClamp?: undefined;
    } | {
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        lodMinClamp: number;
        lodMaxClamp: number;
        anisotropyEnabled?: undefined;
    };
    static _GetWrappingMode(mode: any): any;
    static _GetSamplerWrappingDescriptor(sampler: any): {
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
    };
    static _GetSamplerDescriptor(sampler: any): {
        compare: any;
        maxAnisotropy: number;
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        anisotropyEnabled: boolean;
        lodMinClamp?: undefined;
        lodMaxClamp?: undefined;
    } | {
        compare: any;
        maxAnisotropy: number;
        addressModeU: any;
        addressModeV: any;
        addressModeW: any;
        magFilter: any;
        minFilter: any;
        mipmapFilter: any;
        lodMinClamp: number;
        lodMaxClamp: number;
        anisotropyEnabled?: undefined;
    };
    constructor(device: any);
    _samplers: {};
    _device: any;
    disabled: boolean;
    getSampler(sampler: any, bypassCache?: boolean, hash?: number): any;
}
declare class WebGPUCacheBindGroups {
    static get Statistics(): {
        totalCreated: number;
        lastFrameCreated: number;
        lookupLastFrame: number;
        noLookupLastFrame: number;
    };
    constructor(device: any, cacheSampler: any, engine: any);
    disabled: boolean;
    _device: any;
    _cacheSampler: any;
    _engine: any;
    endFrame(): void;
    getBindGroups(webgpuPipelineContext: any, drawContext: any, materialContext: any): any;
}
declare namespace WebGPUCacheBindGroups {
    const NumBindGroupsCreatedTotal: number;
    const NumBindGroupsCreatedLastFrame: number;
    const NumBindGroupsLookupLastFrame: number;
    const NumBindGroupsNoLookupLastFrame: number;
    const _Cache: WebGPUBindGroupCacheNode;
    const _NumBindGroupsCreatedCurrentFrame: number;
    const _NumBindGroupsLookupCurrentFrame: number;
    const _NumBindGroupsNoLookupCurrentFrame: number;
}
declare class WebGPUTimestampQuery {
    constructor(device: any, bufferManager: any);
    _enabled: boolean;
    _gpuFrameTimeCounter: PerfCounter;
    _measureDurationState: number;
    _device: any;
    _bufferManager: any;
    get gpuFrameTimeCounter(): PerfCounter;
    set enable(arg: boolean);
    get enable(): boolean;
    _measureDuration: WebGPUDurationMeasure;
    startFrame(commandEncoder: any): void;
    endFrame(commandEncoder: any): void;
}
declare class WebGPUOcclusionQuery {
    constructor(engine: any, device: any, bufferManager: any, startCount?: number, incrementCount?: number);
    _availableIndices: any[];
    _engine: any;
    _device: any;
    _bufferManager: any;
    _frameLastBuffer: number;
    _currentTotalIndices: number;
    _countIncrement: number;
    get querySet(): any;
    get hasQueries(): boolean;
    get canBeginQuery(): boolean;
    createQuery(): any;
    deleteQuery(index: any): void;
    isQueryResultAvailable(index: any): boolean;
    getQueryResult(index: any): number;
    _retrieveQueryBuffer(): void;
    _lastBuffer: BigUint64Array;
    _allocateNewIndices(numIndices: any): void;
    _querySet: WebGPUQuerySet;
    _delayQuerySetDispose(): void;
    dispose(): void;
}
declare class WebGPUBundleList {
    constructor(device: any);
    numDrawCalls: number;
    _device: any;
    _list: any[];
    _listLength: number;
    addBundle(bundle: any): void;
    _currentBundleList: any[];
    _currentItemIsBundle: boolean;
    _finishBundle(): void;
    _bundleEncoder: any;
    addItem(item: any): void;
    getBundleEncoder(colorFormats: any, depthStencilFormat: any, sampleCount: any): any;
    close(): void;
    run(renderPass: any): void;
    reset(): void;
    clone(): WebGPUBundleList;
}
declare class WebGPUSnapshotRendering {
    constructor(engine: any, renderingMode: any, bundleList: any, bundleListRenderTarget: any);
    _record: boolean;
    _play: boolean;
    _mainPassBundleList: any[];
    _enabled: boolean;
    _engine: any;
    _mode: any;
    _bundleList: any;
    _bundleListRenderTarget: any;
    set enabled(arg: boolean);
    get enabled(): boolean;
    get play(): boolean;
    get record(): boolean;
    _modeSaved: any;
    set mode(arg: any);
    get mode(): any;
    endMainRenderPass(): void;
    endRenderTargetPass(currentRenderPass: any, gpuWrapper: any): boolean;
    endFrame(mainRenderPass: any): void;
    reset(): void;
}
declare class WebGPUDataBuffer extends DataBuffer {
    constructor(resource: any);
    _buffer: any;
}
declare class VertexBuffer {
    static DeduceStride(kind: any): 2 | 3 | 4;
    static GetTypeByteLength(type: any): 1 | 2 | 4;
    static ForEach(data: any, byteOffset: any, byteStride: any, componentCount: any, componentType: any, count: any, normalized: any, callback: any): void;
    static _GetFloatValue(dataView: any, type: any, byteOffset: any, normalized: any): any;
    constructor(engine: any, data: any, kind: any, updatable: any, postponeInternalCreation: any, stride: any, instanced: any, offset: any, size: any, type: any, normalized?: boolean, useBytes?: boolean, divisor?: number, takeBufferOwnership?: boolean);
    _buffer: Buffer;
    _ownsBuffer: boolean;
    uniqueId: number;
    _kind: any;
    type: any;
    _size: any;
    byteStride: any;
    byteOffset: any;
    normalized: boolean;
    _instanced: any;
    _instanceDivisor: number;
    set instanceDivisor(arg: number);
    get instanceDivisor(): number;
    _computeHashCode(): void;
    hashCode: number;
    _rebuild(): void;
    getKind(): any;
    isUpdatable(): any;
    getData(): any;
    getFloatData(totalVertices: any, forceCopy: any): any;
    getBuffer(): DataBuffer;
    getStrideSize(): number;
    getOffset(): number;
    getSize(sizeInBytes?: boolean): any;
    getIsInstanced(): any;
    getInstanceDivisor(): number;
    create(data: any): void;
    update(data: any): void;
    updateDirectly(data: any, offset: any, useBytes?: boolean): void;
    dispose(): void;
    forEach(count: any, callback: any): void;
}
declare namespace VertexBuffer {
    const _Counter: number;
    const BYTE: number;
    const UNSIGNED_BYTE: number;
    const SHORT: number;
    const UNSIGNED_SHORT: number;
    const INT: number;
    const UNSIGNED_INT: number;
    const FLOAT: number;
    const PositionKind: string;
    const NormalKind: string;
    const TangentKind: string;
    const UVKind: string;
    const UV2Kind: string;
    const UV3Kind: string;
    const UV4Kind: string;
    const UV5Kind: string;
    const UV6Kind: string;
    const ColorKind: string;
    const MatricesIndicesKind: string;
    const MatricesWeightsKind: string;
    const MatricesIndicesExtraKind: string;
    const MatricesWeightsExtraKind: string;
}
declare class WebGPUCacheRenderPipelineTree extends WebGPUCacheRenderPipeline {
    static GetNodeCounts(): {
        nodeCount: number;
        pipelineCount: number;
    };
    static _GetPipelines(node: any, pipelines: any, curPath: any, curPathLen: any): void;
    static GetPipelines(): any[];
    _nodeStack: NodeState[];
    _getRenderPipeline(param: any): void;
    _setRenderPipeline(param: any): void;
}
declare namespace WebGPUCacheRenderPipelineTree {
    const _Cache_1: NodeState;
    export { _Cache_1 as _Cache };
}
declare class WebGPUClearQuad {
    constructor(device: any, engine: any, emptyVertexBuffer: any);
    _bindGroups: {};
    _bundleCache: {};
    _device: any;
    _engine: any;
    _cacheRenderPipeline: WebGPUCacheRenderPipelineTree;
    _effect: any;
    setDepthStencilFormat(format: any): void;
    _depthTextureFormat: any;
    setColorFormat(format: any): void;
    setMRTAttachments(attachments: any, textureArray: any): void;
    clear(renderPass: any, clearColor: any, clearDepth: any, clearStencil: any, sampleCount?: number): any;
}
declare class WebGPUDrawContext {
    constructor(bufferManager: any);
    _bufferManager: any;
    uniqueId: number;
    _useInstancing: boolean;
    _currentInstanceCount: number;
    isDirty(materialContextUpdateId: any): boolean;
    resetIsDirty(materialContextUpdateId: any): void;
    _isDirty: boolean;
    materialContextUpdateId: any;
    set useInstancing(arg: boolean);
    get useInstancing(): boolean;
    indirectDrawBuffer: any;
    _indirectDrawData: Uint32Array;
    reset(): void;
    buffers: {};
    fastBundle: any;
    bindGroups: any;
    setBuffer(name: any, buffer: any): void;
    setIndirectData(indexOrVertexCount: any, instanceCount: any, firstIndexOrVertex: any): void;
    dispose(): void;
}
declare namespace WebGPUDrawContext {
    const _Counter_1: number;
    export { _Counter_1 as _Counter };
}
declare class WebGPUMaterialContext {
    uniqueId: number;
    updateId: number;
    get forceBindGroupCreation(): boolean;
    get hasFloatTextures(): boolean;
    reset(): void;
    samplers: {};
    textures: {};
    isDirty: boolean;
    _numFloatTextures: number;
    _numExternalTextures: number;
    setSampler(name: any, sampler: any): void;
    setTexture(name: any, texture: any): void;
}
declare namespace WebGPUMaterialContext {
    const _Counter_2: number;
    export { _Counter_2 as _Counter };
}
declare class ThinEngine {
    static get NpmPackage(): string;
    static get Version(): string;
    static set ShadersRepository(arg: string);
    static get ShadersRepository(): string;
    static _createCanvas(width: any, height: any): any;
    static _ConcatenateShader(source: any, defines: any, shaderVersion?: string): string;
    static _FileToolsLoadImage(input: any, onLoad: any, onError: any, offlineProvider: any, mimeType: any, imageBitmapOptions: any): void;
    static _FileToolsLoadFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any): void;
    static get IsSupportedAsync(): Promise<boolean>;
    static get IsSupported(): boolean;
    static isSupported(): boolean;
    static get HasMajorPerformanceCaveat(): boolean;
    static CeilingPOT(x: any): any;
    static FloorPOT(x: any): number;
    static NearestPOT(x: any): any;
    static GetExponentOfTwo(value: any, max: any, mode?: number): number;
    static QueueNewFrame(func: any, requester: any): any;
    constructor(canvasOrContext: any, antialias: any, options: any, adaptToDeviceRatio: any);
    forcePOTTextures: boolean;
    isFullscreen: boolean;
    cullBackFaces: any;
    renderEvenInBackground: boolean;
    preventCacheWipeBetweenFrames: boolean;
    validateShaderPrograms: boolean;
    _useReverseDepthBuffer: boolean;
    isNDCHalfZRange: boolean;
    hasOriginBottomLeft: boolean;
    disableUniformBuffers: boolean;
    onDisposeObservable: Observable;
    _frameId: number;
    _uniformBuffers: any[];
    _storageBuffers: any[];
    _webGLVersion: number;
    _windowIsBackground: boolean;
    _highPrecisionShadersAllowed: any;
    _badOS: boolean;
    _badDesktopOS: boolean;
    _renderingQueueLaunched: boolean;
    _activeRenderLoops: any[];
    onContextLostObservable: Observable;
    onContextRestoredObservable: Observable;
    _contextWasLost: boolean;
    _doNotHandleContextLost: boolean;
    disableVertexArrayObjects: boolean;
    _colorWrite: boolean;
    _colorWriteChanged: boolean;
    _depthCullingState: DepthCullingState;
    _stencilStateComposer: StencilStateComposer;
    _stencilState: StencilState;
    _alphaState: AlphaState;
    _alphaMode: number;
    _alphaEquation: number;
    _internalTexturesCache: any[];
    _renderTargetWrapperCache: any[];
    _activeChannel: number;
    _currentTextureChannel: number;
    _boundTexturesCache: {};
    _compiledEffects: {};
    _vertexAttribArraysEnabled: any[];
    _uintIndicesCurrentlySet: boolean;
    _currentBoundBuffer: any[];
    _currentFramebuffer: any;
    _dummyFramebuffer: any;
    _currentBufferPointers: any[];
    _currentInstanceLocations: any[];
    _currentInstanceBuffers: any[];
    _vaoRecordInProgress: boolean;
    _mustWipeVertexAttributes: boolean;
    _nextFreeTextureSlots: any[];
    _maxSimultaneousTextures: number;
    _activeRequests: any[];
    _transformTextureUrl: any;
    hostInformation: {
        isMobile: boolean;
    };
    premultipliedAlpha: boolean;
    onBeforeTextureInitObservable: Observable;
    _isWebGPU: boolean;
    _snapshotRenderingMode: number;
    _viewportCached: {
        x: number;
        y: number;
        z: number;
        w: number;
    };
    _unpackFlipYCached: any;
    enableUnpackFlipYCached: boolean;
    _boundUniforms: {};
    _renderingCanvas: any;
    _audioContext: any;
    _audioDestination: any;
    _checkForMobile: () => void;
    _onContextLost: (evt: any) => void;
    _onContextRestored: () => void;
    _gl: any;
    _shaderPlatformName: string;
    _hardwareScalingLevel: number;
    _isStencilEnable: boolean;
    _shaderProcessor: WebGLShaderProcessor | WebGL2ShaderProcessor;
    _creationOptions: any;
    get description(): string;
    get name(): string;
    get version(): number;
    _getShaderProcessor(shaderLanguage: any): WebGLShaderProcessor | WebGL2ShaderProcessor;
    set useReverseDepthBuffer(arg: boolean);
    get useReverseDepthBuffer(): boolean;
    get frameId(): number;
    get supportsUniformBuffers(): boolean;
    get _shouldUseHighPrecisionShader(): boolean;
    get needPOTTextures(): boolean;
    get activeRenderLoops(): any[];
    set doNotHandleContextLost(arg: boolean);
    get doNotHandleContextLost(): boolean;
    get _supportsHardwareTextureRescaling(): boolean;
    set framebufferDimensionsObject(arg: any);
    _framebufferDimensionsObject: any;
    get currentViewport(): any;
    get emptyTexture(): void;
    _emptyTexture: void;
    get emptyTexture3D(): void;
    _emptyTexture3D: void;
    get emptyTexture2DArray(): void;
    _emptyTexture2DArray: void;
    get emptyCubeTexture(): void;
    _emptyCubeTexture: void;
    get isWebGPU(): boolean;
    get shaderPlatformName(): string;
    set snapshotRendering(arg: boolean);
    get snapshotRendering(): boolean;
    set snapshotRenderingMode(arg: number);
    get snapshotRenderingMode(): number;
    snapshotRenderingReset(): void;
    createCanvas(width: any, height: any): any;
    createCanvasImage(): HTMLImageElement;
    _restoreEngineAfterContextLost(initEngine: any): void;
    _sharedInit(canvas: any, doNotHandleTouchAction: any, audioEngine: any): void;
    _getShaderProcessingContext(shaderLanguage: any): any;
    _rebuildInternalTextures(): void;
    _rebuildRenderTargetWrappers(): void;
    _rebuildEffects(): void;
    areAllEffectsReady(): boolean;
    _rebuildBuffers(): void;
    _initGLContext(): void;
    _caps: {
        maxTexturesImageUnits: any;
        maxCombinedTexturesImageUnits: any;
        maxVertexTextureImageUnits: any;
        maxTextureSize: any;
        maxSamples: any;
        maxCubemapTextureSize: any;
        maxRenderTextureSize: any;
        maxVertexAttribs: any;
        maxVaryingVectors: any;
        maxFragmentUniformVectors: any;
        maxVertexUniformVectors: any;
        parallelShaderCompile: any;
        standardDerivatives: boolean;
        maxAnisotropy: number;
        astc: any;
        bptc: any;
        s3tc: any;
        s3tc_srgb: any;
        pvrtc: any;
        etc1: any;
        etc2: any;
        textureAnisotropicFilterExtension: any;
        uintIndices: boolean;
        fragmentDepthSupported: boolean;
        highPrecisionShaderSupported: boolean;
        timerQuery: any;
        supportOcclusionQuery: boolean;
        canUseTimestampForTimerQuery: boolean;
        drawBuffersExtension: boolean;
        maxMSAASamples: number;
        colorBufferFloat: boolean;
        textureFloat: boolean;
        textureHalfFloat: boolean;
        textureHalfFloatRender: boolean;
        textureFloatLinearFiltering: boolean;
        textureFloatRender: boolean;
        textureHalfFloatLinearFiltering: boolean;
        vertexArrayObject: boolean;
        instancedArrays: boolean;
        textureLOD: boolean;
        blendMinMax: boolean;
        multiview: any;
        oculusMultiview: any;
        depthTextureExtension: boolean;
        canUseGLInstanceID: boolean;
        canUseGLVertexID: boolean;
        supportComputeShaders: boolean;
        supportSRGBBuffers: boolean;
    };
    _glVersion: any;
    _glRenderer: any;
    _glVendor: any;
    _initFeatures(): void;
    _features: {
        forceBitmapOverHTMLImageElement: boolean;
        supportRenderAndCopyToLodForFloatTextures: boolean;
        supportDepthStencilTexture: boolean;
        supportShadowSamplers: boolean;
        uniformBufferHardCheckMatrix: boolean;
        allowTexturePrefiltering: boolean;
        trackUbosInFrame: boolean;
        checkUbosContentBeforeUpload: boolean;
        supportCSM: boolean;
        basisNeedsPOT: boolean;
        support3DTextures: boolean;
        needTypeSuffixInShaderConstants: boolean;
        supportMSAA: boolean;
        supportSSAO2: boolean;
        supportExtendedTextureFormats: boolean;
        supportSwitchCaseInShader: boolean;
        supportSyncTextureRead: boolean;
        needsInvertingBitmap: boolean;
        useUBOBindingCache: boolean;
        needShaderCodeInlining: boolean;
        needToAlwaysBindUniformBuffers: boolean;
        supportRenderPasses: boolean;
        _collectUbosUpdatedInFrame: boolean;
    };
    get webGLVersion(): number;
    getClassName(): string;
    get isStencilEnable(): boolean;
    _prepareWorkingCanvas(): void;
    _workingCanvas: any;
    _workingContext: any;
    resetTextureCache(): void;
    getInfo(): {
        vendor: any;
        renderer: any;
        version: any;
    };
    getGlInfo(): {
        vendor: any;
        renderer: any;
        version: any;
    };
    setHardwareScalingLevel(level: any): void;
    getHardwareScalingLevel(): number;
    getLoadedTexturesCache(): any[];
    getCaps(): {
        maxTexturesImageUnits: any;
        maxCombinedTexturesImageUnits: any;
        maxVertexTextureImageUnits: any;
        maxTextureSize: any;
        maxSamples: any;
        maxCubemapTextureSize: any;
        maxRenderTextureSize: any;
        maxVertexAttribs: any;
        maxVaryingVectors: any;
        maxFragmentUniformVectors: any;
        maxVertexUniformVectors: any;
        parallelShaderCompile: any;
        standardDerivatives: boolean;
        maxAnisotropy: number;
        astc: any;
        bptc: any;
        s3tc: any;
        s3tc_srgb: any;
        pvrtc: any;
        etc1: any;
        etc2: any;
        textureAnisotropicFilterExtension: any;
        uintIndices: boolean;
        fragmentDepthSupported: boolean;
        highPrecisionShaderSupported: boolean;
        timerQuery: any;
        supportOcclusionQuery: boolean;
        canUseTimestampForTimerQuery: boolean;
        drawBuffersExtension: boolean;
        maxMSAASamples: number;
        colorBufferFloat: boolean;
        textureFloat: boolean;
        textureHalfFloat: boolean;
        textureHalfFloatRender: boolean;
        textureFloatLinearFiltering: boolean;
        textureFloatRender: boolean;
        textureHalfFloatLinearFiltering: boolean;
        vertexArrayObject: boolean;
        instancedArrays: boolean;
        textureLOD: boolean;
        blendMinMax: boolean;
        multiview: any;
        oculusMultiview: any;
        depthTextureExtension: boolean;
        canUseGLInstanceID: boolean;
        canUseGLVertexID: boolean;
        supportComputeShaders: boolean;
        supportSRGBBuffers: boolean;
    };
    stopRenderLoop(renderFunction: any): void;
    _renderLoop(): void;
    _frameHandler: any;
    getRenderingCanvas(): any;
    getAudioContext(): any;
    getAudioDestination(): any;
    getHostWindow(): any;
    getRenderWidth(useScreen?: boolean): any;
    getRenderHeight(useScreen?: boolean): any;
    _queueNewFrame(bindedRenderFunction: any, requester: any): any;
    runRenderLoop(renderFunction: any): void;
    _boundRenderFunction: any;
    clear(color: any, backBuffer: any, depth: any, stencil?: boolean): void;
    _viewport(x: any, y: any, width: any, height: any): void;
    setViewport(viewport: any, requiredWidth: any, requiredHeight: any): void;
    _cachedViewport: any;
    beginFrame(): void;
    endFrame(): void;
    resize(forceSetSize?: boolean): void;
    setSize(width: any, height: any, forceSetSize?: boolean): boolean;
    bindFramebuffer(texture: any, faceIndex: number, requiredWidth: any, requiredHeight: any, forceFullscreenViewport: any, lodLevel?: number, layer?: number): void;
    _currentRenderTarget: any;
    setState(culling: any, zOffset: number, force: any, reverseSide: boolean, cullBackFaces: any, stencil: any, zOffsetUnits?: number): void;
    setZOffset(value: any): void;
    getZOffset(): any;
    setZOffsetUnits(value: any): void;
    getZOffsetUnits(): any;
    _bindUnboundFramebuffer(framebuffer: any): void;
    _currentFrameBufferIsDefaultFrameBuffer(): boolean;
    generateMipmaps(texture: any): void;
    unBindFramebuffer(texture: any, disableGenerateMipMaps: boolean, onBeforeUnbind: any): void;
    flushFramebuffer(): void;
    restoreDefaultFramebuffer(): void;
    _resetVertexBufferBinding(): void;
    _cachedVertexBuffers: any;
    createVertexBuffer(data: any): WebGLDataBuffer;
    _createVertexBuffer(data: any, usage: any): WebGLDataBuffer;
    createDynamicVertexBuffer(data: any): WebGLDataBuffer;
    _resetIndexBufferBinding(): void;
    _cachedIndexBuffer: any;
    createIndexBuffer(indices: any, updatable: any): WebGLDataBuffer;
    _normalizeIndexData(indices: any): any;
    bindArrayBuffer(buffer: any): void;
    bindUniformBlock(pipelineContext: any, blockName: any, index: any): void;
    bindIndexBuffer(buffer: any): void;
    bindBuffer(buffer: any, target: any): void;
    updateArrayBuffer(data: any): void;
    _vertexAttribPointer(buffer: any, indx: any, size: any, type: any, normalized: any, stride: any, offset: any): void;
    _bindIndexBufferWithCache(indexBuffer: any): void;
    _bindVertexBuffersAttributes(vertexBuffers: any, effect: any, overrideVertexBuffers: any): void;
    recordVertexArrayObject(vertexBuffers: any, indexBuffer: any, effect: any, overrideVertexBuffers: any): any;
    bindVertexArrayObject(vertexArrayObject: any, indexBuffer: any): void;
    _cachedVertexArrayObject: any;
    bindBuffersDirectly(vertexBuffer: any, indexBuffer: any, vertexDeclaration: any, vertexStrideSize: any, effect: any): void;
    _cachedEffectForVertexBuffers: any;
    _unbindVertexArrayObject(): void;
    bindBuffers(vertexBuffers: any, indexBuffer: any, effect: any, overrideVertexBuffers: any): void;
    unbindInstanceAttributes(): void;
    releaseVertexArrayObject(vao: any): void;
    _releaseBuffer(buffer: any): boolean;
    _deleteBuffer(buffer: any): void;
    updateAndBindInstancesBuffer(instancesBuffer: any, data: any, offsetLocations: any): void;
    bindInstancesBuffer(instancesBuffer: any, attributesInfo: any, computeStride?: boolean): void;
    disableInstanceAttributeByName(name: any): void;
    disableInstanceAttribute(attributeLocation: any): void;
    disableAttributeByIndex(attributeLocation: any): void;
    draw(useTriangles: any, indexStart: any, indexCount: any, instancesCount: any): void;
    drawPointClouds(verticesStart: any, verticesCount: any, instancesCount: any): void;
    drawUnIndexed(useTriangles: any, verticesStart: any, verticesCount: any, instancesCount: any): void;
    drawElementsType(fillMode: any, indexStart: any, indexCount: any, instancesCount: any): void;
    drawArraysType(fillMode: any, verticesStart: any, verticesCount: any, instancesCount: any): void;
    _drawMode(fillMode: any): any;
    _reportDrawCall(): void;
    _releaseEffect(effect: any): void;
    _deletePipelineContext(pipelineContext: any): void;
    _getGlobalDefines(defines: any): string;
    createEffect(baseName: any, attributesNamesOrOptions: any, uniformsNamesOrEngine: any, samplers: any, defines: any, fallbacks: any, onCompiled: any, onError: any, indexParameters: any, shaderLanguage?: any): any;
    _compileShader(source: any, type: any, defines: any, shaderVersion: any): any;
    _compileRawShader(source: any, type: any): any;
    _getShaderSource(shader: any): any;
    createRawShaderProgram(pipelineContext: any, vertexCode: any, fragmentCode: any, context: any, transformFeedbackVaryings?: any): any;
    createShaderProgram(pipelineContext: any, vertexCode: any, fragmentCode: any, defines: any, context: any, transformFeedbackVaryings?: any): any;
    inlineShaderCode(code: any): any;
    createPipelineContext(shaderProcessingContext: any): WebGLPipelineContext;
    createMaterialContext(): any;
    createDrawContext(): any;
    _createShaderProgram(pipelineContext: any, vertexShader: any, fragmentShader: any, context: any, transformFeedbackVaryings?: any): any;
    _finalizePipelineContext(pipelineContext: any): void;
    _preparePipelineContext(pipelineContext: any, vertexSourceCode: any, fragmentSourceCode: any, createAsRaw: any, rawVertexSourceCode: any, rawFragmentSourceCode: any, rebuildRebind: any, defines: any, transformFeedbackVaryings: any, key: any): void;
    _isRenderingStateCompiled(pipelineContext: any): boolean;
    _executeWhenRenderingStateIsCompiled(pipelineContext: any, action: any): void;
    getUniforms(pipelineContext: any, uniformsNames: any): any[];
    getAttributes(pipelineContext: any, attributesNames: any): any[];
    enableEffect(effect: any): void;
    _currentEffect: any;
    setInt(uniform: any, value: any): boolean;
    setInt2(uniform: any, x: any, y: any): boolean;
    setInt3(uniform: any, x: any, y: any, z: any): boolean;
    setInt4(uniform: any, x: any, y: any, z: any, w: any): boolean;
    setIntArray(uniform: any, array: any): boolean;
    setIntArray2(uniform: any, array: any): boolean;
    setIntArray3(uniform: any, array: any): boolean;
    setIntArray4(uniform: any, array: any): boolean;
    setArray(uniform: any, array: any): boolean;
    setArray2(uniform: any, array: any): boolean;
    setArray3(uniform: any, array: any): boolean;
    setArray4(uniform: any, array: any): boolean;
    setMatrices(uniform: any, matrices: any): boolean;
    setMatrix3x3(uniform: any, matrix: any): boolean;
    setMatrix2x2(uniform: any, matrix: any): boolean;
    setFloat(uniform: any, value: any): boolean;
    setFloat2(uniform: any, x: any, y: any): boolean;
    setFloat3(uniform: any, x: any, y: any, z: any): boolean;
    setFloat4(uniform: any, x: any, y: any, z: any, w: any): boolean;
    applyStates(): void;
    setColorWrite(enable: any): void;
    getColorWrite(): boolean;
    get depthCullingState(): DepthCullingState;
    get alphaState(): AlphaState;
    get stencilState(): StencilState;
    get stencilStateComposer(): StencilStateComposer;
    clearInternalTexturesCache(): void;
    wipeCaches(bruteForce: any): void;
    _currentProgram: any;
    _getSamplingParameters(samplingMode: any, generateMipMaps: any): {
        min: any;
        mag: any;
    };
    _createTexture(): any;
    _createHardwareTexture(): WebGLHardwareTexture;
    _createInternalTexture(size: any, options: any, delayGPUTextureCreation?: boolean, source?: any): InternalTexture;
    _getUseSRGBBuffer(useSRGBBuffer: any, noMipmap: any): any;
    _createTextureBase(url: any, noMipmap: any, invertY: any, scene: any, samplingMode: number, onLoad: any, onError: any, prepareTexture: any, prepareTextureProcessFunction: any, buffer: any, fallback: any, format: any, forcedExtension: any, mimeType: any, loaderOptions: any, useSRGBBuffer: any): any;
    createTexture(url: any, noMipmap: any, invertY: any, scene: any, samplingMode: number, onLoad: any, onError: any, buffer: any, fallback: any, format: any, forcedExtension: any, mimeType: any, loaderOptions: any, creationFlags: any, useSRGBBuffer: any): any;
    _rescaleTexture(source: any, destination: any, scene: any, internalFormat: any, onComplete: any): void;
    createRawTexture(data: any, width: any, height: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, type?: number): void;
    createRawCubeTexture(data: any, size: any, format: any, type: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any): void;
    createRawTexture3D(data: any, width: any, height: any, depth: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, textureType?: number): void;
    createRawTexture2DArray(data: any, width: any, height: any, depth: any, format: any, generateMipMaps: any, invertY: any, samplingMode: any, compression?: any, textureType?: number): void;
    _unpackFlipY(value: any): void;
    _getUnpackAlignement(): any;
    _getTextureTarget(texture: any): any;
    updateTextureSamplingMode(samplingMode: any, texture: any, generateMipMaps?: boolean): void;
    updateTextureDimensions(texture: any, width: any, height: any, depth?: number): void;
    updateTextureWrappingMode(texture: any, wrapU: any, wrapV?: any, wrapR?: any): void;
    _setupDepthStencilTexture(internalTexture: any, size: any, generateStencil: any, bilinearFiltering: any, comparisonFunction: any, samples?: number): void;
    _uploadCompressedDataToTextureDirectly(texture: any, internalFormat: any, width: any, height: any, data: any, faceIndex?: number, lod?: number): void;
    _uploadDataToTextureDirectly(texture: any, imageData: any, faceIndex: number, lod: number, babylonInternalFormat: any, useTextureWidthAndHeight?: boolean): void;
    updateTextureData(texture: any, imageData: any, xOffset: any, yOffset: any, width: any, height: any, faceIndex?: number, lod?: number): void;
    _uploadArrayBufferViewToTexture(texture: any, imageData: any, faceIndex?: number, lod?: number): void;
    _prepareWebGLTextureContinuation(texture: any, scene: any, noMipmap: any, isCompressed: any, samplingMode: any): void;
    _prepareWebGLTexture(texture: any, extension: any, scene: any, img: any, invertY: any, noMipmap: any, isCompressed: any, processFunction: any, samplingMode?: number): void;
    _setupFramebufferDepthAttachments(generateStencilBuffer: any, generateDepthBuffer: any, width: any, height: any, samples?: number): any;
    _createRenderBuffer(width: any, height: any, samples: any, internalFormat: any, msInternalFormat: any, attachment: any, unbindBuffer?: boolean): any;
    _releaseTexture(texture: any): void;
    _releaseRenderTargetWrapper(rtWrapper: any): void;
    _deleteTexture(texture: any): void;
    _setProgram(program: any): void;
    bindSamplers(effect: any): void;
    _activateCurrentTexture(): void;
    _bindTextureDirectly(target: any, texture: any, forTextureDataUpdate?: boolean, force?: boolean): boolean;
    _bindTexture(channel: any, texture: any, name: any): void;
    unbindAllTextures(): void;
    setTexture(channel: any, uniform: any, texture: any, name: any): void;
    _bindSamplerUniformToChannel(sourceSlot: any, destination: any): void;
    _getTextureWrapMode(mode: any): any;
    _setTexture(channel: any, texture: any, isPartOfTextureArray?: boolean, depthStencilTexture?: boolean, name?: string): boolean;
    setTextureArray(channel: any, uniform: any, textures: any, name: any): void;
    _textureUnits: Int32Array;
    _setAnisotropicLevel(target: any, internalTexture: any, anisotropicFilteringLevel: any): void;
    _setTextureParameterFloat(target: any, parameter: any, value: any, texture: any): void;
    _setTextureParameterInteger(target: any, parameter: any, value: any, texture: any): void;
    unbindAllAttributes(): void;
    releaseEffects(): void;
    dispose(): void;
    attachContextLostEvent(callback: any): void;
    attachContextRestoredEvent(callback: any): void;
    getError(): any;
    _canRenderToFloatFramebuffer(): boolean;
    _canRenderToHalfFloatFramebuffer(): boolean;
    _canRenderToFramebuffer(type: any): boolean;
    _getWebGLTextureType(type: any): any;
    _getInternalFormat(format: any, useSRGBBuffer?: boolean): any;
    _getRGBABufferInternalSizedFormat(type: any, format: any, useSRGBBuffer?: boolean): any;
    _getRGBAMultiSampleBufferFormat(type: any): any;
    _loadFile(url: any, onSuccess: any, onProgress: any, offlineProvider: any, useArrayBuffer: any, onError: any): void;
    readPixels(x: any, y: any, width: any, height: any, hasAlpha?: boolean, flushRenderer?: boolean): Promise<Uint8Array>;
    getHostDocument(): any;
    _readTexturePixelsSync(texture: any, width: any, height: any, faceIndex?: number, level?: number, buffer?: any, flushRenderer?: boolean, noDataConversion?: boolean): any;
    _readTexturePixels(texture: any, width: any, height: any, faceIndex?: number, level?: number, buffer?: any, flushRenderer?: boolean, noDataConversion?: boolean): Promise<any>;
}
declare namespace ThinEngine {
    const _IsSupported: boolean;
    const _HasMajorPerformanceCaveat: boolean;
    const ExceptionList: {
        key: string;
        capture: string;
        captureConstraint: number;
        targets: string[];
    }[];
    const _TextureLoaders: any[];
    const CollisionsEpsilon: number;
}
declare class PerfCounter {
    _startMonitoringTime: number;
    _min: number;
    _max: number;
    _average: number;
    _lastSecAverage: number;
    _current: number;
    _totalValueCount: number;
    _totalAccumulated: number;
    _lastSecAccumulated: number;
    _lastSecTime: number;
    _lastSecValueCount: number;
    get min(): number;
    get max(): number;
    get average(): number;
    get lastSecAverage(): number;
    get current(): number;
    get total(): number;
    get count(): number;
    fetchNewFrame(): void;
    addCount(newCount: any, fetchResult: any): void;
    beginMonitoring(): void;
    endMonitoring(newFrame?: boolean): void;
    _fetchResult(): void;
}
declare namespace PerfCounter {
    const Enabled: boolean;
}
declare class PerformanceMonitor {
    constructor(frameSampleSize?: number);
    _enabled: boolean;
    _rollingFrameTime: RollingAverage;
    sampleFrame(timeMs?: number): void;
    _lastFrameTimeMs: number;
    get averageFrameTime(): number;
    get averageFrameTimeVariance(): number;
    get instantaneousFrameTime(): any;
    get averageFPS(): number;
    get instantaneousFPS(): number;
    get isSaturated(): boolean;
    enable(): void;
    disable(): void;
    get isEnabled(): boolean;
    reset(): void;
}
declare class WebGLDataBuffer extends DataBuffer {
    constructor(resource: any);
    _buffer: any;
}
declare class Constants {
}
declare namespace Constants {
    const ALPHA_DISABLE_1: number;
    export { ALPHA_DISABLE_1 as ALPHA_DISABLE };
    const ALPHA_ADD_1: number;
    export { ALPHA_ADD_1 as ALPHA_ADD };
    const ALPHA_COMBINE_1: number;
    export { ALPHA_COMBINE_1 as ALPHA_COMBINE };
    const ALPHA_SUBTRACT_1: number;
    export { ALPHA_SUBTRACT_1 as ALPHA_SUBTRACT };
    const ALPHA_MULTIPLY_1: number;
    export { ALPHA_MULTIPLY_1 as ALPHA_MULTIPLY };
    const ALPHA_MAXIMIZED_1: number;
    export { ALPHA_MAXIMIZED_1 as ALPHA_MAXIMIZED };
    const ALPHA_ONEONE_1: number;
    export { ALPHA_ONEONE_1 as ALPHA_ONEONE };
    const ALPHA_PREMULTIPLIED_1: number;
    export { ALPHA_PREMULTIPLIED_1 as ALPHA_PREMULTIPLIED };
    const ALPHA_PREMULTIPLIED_PORTERDUFF_1: number;
    export { ALPHA_PREMULTIPLIED_PORTERDUFF_1 as ALPHA_PREMULTIPLIED_PORTERDUFF };
    const ALPHA_INTERPOLATE_1: number;
    export { ALPHA_INTERPOLATE_1 as ALPHA_INTERPOLATE };
    const ALPHA_SCREENMODE_1: number;
    export { ALPHA_SCREENMODE_1 as ALPHA_SCREENMODE };
    export const ALPHA_ONEONE_ONEONE: number;
    export const ALPHA_ALPHATOCOLOR: number;
    export const ALPHA_REVERSEONEMINUS: number;
    export const ALPHA_SRC_DSTONEMINUSSRCALPHA: number;
    export const ALPHA_ONEONE_ONEZERO: number;
    export const ALPHA_EXCLUSION: number;
    export const ALPHA_LAYER_ACCUMULATE: number;
    export const ALPHA_EQUATION_ADD: number;
    export const ALPHA_EQUATION_SUBSTRACT: number;
    export const ALPHA_EQUATION_REVERSE_SUBTRACT: number;
    export const ALPHA_EQUATION_MAX: number;
    export const ALPHA_EQUATION_MIN: number;
    export const ALPHA_EQUATION_DARKEN: number;
    const DELAYLOADSTATE_NONE_1: number;
    export { DELAYLOADSTATE_NONE_1 as DELAYLOADSTATE_NONE };
    const DELAYLOADSTATE_LOADED_1: number;
    export { DELAYLOADSTATE_LOADED_1 as DELAYLOADSTATE_LOADED };
    const DELAYLOADSTATE_LOADING_1: number;
    export { DELAYLOADSTATE_LOADING_1 as DELAYLOADSTATE_LOADING };
    const DELAYLOADSTATE_NOTLOADED_1: number;
    export { DELAYLOADSTATE_NOTLOADED_1 as DELAYLOADSTATE_NOTLOADED };
    const NEVER_1: number;
    export { NEVER_1 as NEVER };
    const ALWAYS_1: number;
    export { ALWAYS_1 as ALWAYS };
    const LESS_1: number;
    export { LESS_1 as LESS };
    const EQUAL_1: number;
    export { EQUAL_1 as EQUAL };
    const LEQUAL_1: number;
    export { LEQUAL_1 as LEQUAL };
    const GREATER_1: number;
    export { GREATER_1 as GREATER };
    const GEQUAL_1: number;
    export { GEQUAL_1 as GEQUAL };
    const NOTEQUAL_1: number;
    export { NOTEQUAL_1 as NOTEQUAL };
    const KEEP_1: number;
    export { KEEP_1 as KEEP };
    export const ZERO: number;
    const REPLACE_1: number;
    export { REPLACE_1 as REPLACE };
    const INCR_1: number;
    export { INCR_1 as INCR };
    const DECR_1: number;
    export { DECR_1 as DECR };
    const INVERT_1: number;
    export { INVERT_1 as INVERT };
    const INCR_WRAP_1: number;
    export { INCR_WRAP_1 as INCR_WRAP };
    const DECR_WRAP_1: number;
    export { DECR_WRAP_1 as DECR_WRAP };
    const TEXTURE_CLAMP_ADDRESSMODE_1: number;
    export { TEXTURE_CLAMP_ADDRESSMODE_1 as TEXTURE_CLAMP_ADDRESSMODE };
    const TEXTURE_WRAP_ADDRESSMODE_1: number;
    export { TEXTURE_WRAP_ADDRESSMODE_1 as TEXTURE_WRAP_ADDRESSMODE };
    const TEXTURE_MIRROR_ADDRESSMODE_1: number;
    export { TEXTURE_MIRROR_ADDRESSMODE_1 as TEXTURE_MIRROR_ADDRESSMODE };
    export const TEXTURE_CREATIONFLAG_STORAGE: number;
    const TEXTUREFORMAT_ALPHA_1: number;
    export { TEXTUREFORMAT_ALPHA_1 as TEXTUREFORMAT_ALPHA };
    const TEXTUREFORMAT_LUMINANCE_1: number;
    export { TEXTUREFORMAT_LUMINANCE_1 as TEXTUREFORMAT_LUMINANCE };
    const TEXTUREFORMAT_LUMINANCE_ALPHA_1: number;
    export { TEXTUREFORMAT_LUMINANCE_ALPHA_1 as TEXTUREFORMAT_LUMINANCE_ALPHA };
    const TEXTUREFORMAT_RGB_1: number;
    export { TEXTUREFORMAT_RGB_1 as TEXTUREFORMAT_RGB };
    const TEXTUREFORMAT_RGBA_1: number;
    export { TEXTUREFORMAT_RGBA_1 as TEXTUREFORMAT_RGBA };
    const TEXTUREFORMAT_RED_1: number;
    export { TEXTUREFORMAT_RED_1 as TEXTUREFORMAT_RED };
    const TEXTUREFORMAT_R_1: number;
    export { TEXTUREFORMAT_R_1 as TEXTUREFORMAT_R };
    const TEXTUREFORMAT_RG_1: number;
    export { TEXTUREFORMAT_RG_1 as TEXTUREFORMAT_RG };
    const TEXTUREFORMAT_RED_INTEGER_1: number;
    export { TEXTUREFORMAT_RED_INTEGER_1 as TEXTUREFORMAT_RED_INTEGER };
    const TEXTUREFORMAT_R_INTEGER_1: number;
    export { TEXTUREFORMAT_R_INTEGER_1 as TEXTUREFORMAT_R_INTEGER };
    const TEXTUREFORMAT_RG_INTEGER_1: number;
    export { TEXTUREFORMAT_RG_INTEGER_1 as TEXTUREFORMAT_RG_INTEGER };
    const TEXTUREFORMAT_RGB_INTEGER_1: number;
    export { TEXTUREFORMAT_RGB_INTEGER_1 as TEXTUREFORMAT_RGB_INTEGER };
    const TEXTUREFORMAT_RGBA_INTEGER_1: number;
    export { TEXTUREFORMAT_RGBA_INTEGER_1 as TEXTUREFORMAT_RGBA_INTEGER };
    export const TEXTUREFORMAT_BGRA: number;
    export const TEXTUREFORMAT_DEPTH24_STENCIL8: number;
    export const TEXTUREFORMAT_DEPTH32_FLOAT: number;
    export const TEXTUREFORMAT_DEPTH16: number;
    export const TEXTUREFORMAT_DEPTH24: number;
    export const TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM: number;
    export const TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT: number;
    export const TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT: number;
    export const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5: number;
    export const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3: number;
    export const TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1: number;
    export const TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1: number;
    export const TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4: number;
    export const TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL: number;
    const TEXTURETYPE_UNSIGNED_BYTE_1: number;
    export { TEXTURETYPE_UNSIGNED_BYTE_1 as TEXTURETYPE_UNSIGNED_BYTE };
    const TEXTURETYPE_UNSIGNED_INT_1: number;
    export { TEXTURETYPE_UNSIGNED_INT_1 as TEXTURETYPE_UNSIGNED_INT };
    const TEXTURETYPE_FLOAT_1: number;
    export { TEXTURETYPE_FLOAT_1 as TEXTURETYPE_FLOAT };
    const TEXTURETYPE_HALF_FLOAT_1: number;
    export { TEXTURETYPE_HALF_FLOAT_1 as TEXTURETYPE_HALF_FLOAT };
    const TEXTURETYPE_BYTE_1: number;
    export { TEXTURETYPE_BYTE_1 as TEXTURETYPE_BYTE };
    const TEXTURETYPE_SHORT_1: number;
    export { TEXTURETYPE_SHORT_1 as TEXTURETYPE_SHORT };
    const TEXTURETYPE_UNSIGNED_SHORT_1: number;
    export { TEXTURETYPE_UNSIGNED_SHORT_1 as TEXTURETYPE_UNSIGNED_SHORT };
    const TEXTURETYPE_INT_1: number;
    export { TEXTURETYPE_INT_1 as TEXTURETYPE_INT };
    const TEXTURETYPE_UNSIGNED_INTEGER_1: number;
    export { TEXTURETYPE_UNSIGNED_INTEGER_1 as TEXTURETYPE_UNSIGNED_INTEGER };
    const TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4_1: number;
    export { TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4_1 as TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 };
    const TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1_1: number;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1_1 as TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 };
    const TEXTURETYPE_UNSIGNED_SHORT_5_6_5_1: number;
    export { TEXTURETYPE_UNSIGNED_SHORT_5_6_5_1 as TEXTURETYPE_UNSIGNED_SHORT_5_6_5 };
    const TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV_1: number;
    export { TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV_1 as TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV };
    const TEXTURETYPE_UNSIGNED_INT_24_8_1: number;
    export { TEXTURETYPE_UNSIGNED_INT_24_8_1 as TEXTURETYPE_UNSIGNED_INT_24_8 };
    const TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV_1: number;
    export { TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV_1 as TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV };
    const TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV_1: number;
    export { TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV_1 as TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV };
    const TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV_1: number;
    export { TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV_1 as TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV };
    export const TEXTURETYPE_UNDEFINED: number;
    const TEXTURE_NEAREST_SAMPLINGMODE_1: number;
    export { TEXTURE_NEAREST_SAMPLINGMODE_1 as TEXTURE_NEAREST_SAMPLINGMODE };
    const TEXTURE_NEAREST_NEAREST_1: number;
    export { TEXTURE_NEAREST_NEAREST_1 as TEXTURE_NEAREST_NEAREST };
    const TEXTURE_BILINEAR_SAMPLINGMODE_1: number;
    export { TEXTURE_BILINEAR_SAMPLINGMODE_1 as TEXTURE_BILINEAR_SAMPLINGMODE };
    const TEXTURE_LINEAR_LINEAR_1: number;
    export { TEXTURE_LINEAR_LINEAR_1 as TEXTURE_LINEAR_LINEAR };
    const TEXTURE_TRILINEAR_SAMPLINGMODE_1: number;
    export { TEXTURE_TRILINEAR_SAMPLINGMODE_1 as TEXTURE_TRILINEAR_SAMPLINGMODE };
    const TEXTURE_LINEAR_LINEAR_MIPLINEAR_1: number;
    export { TEXTURE_LINEAR_LINEAR_MIPLINEAR_1 as TEXTURE_LINEAR_LINEAR_MIPLINEAR };
    const TEXTURE_NEAREST_NEAREST_MIPNEAREST_1: number;
    export { TEXTURE_NEAREST_NEAREST_MIPNEAREST_1 as TEXTURE_NEAREST_NEAREST_MIPNEAREST };
    const TEXTURE_NEAREST_LINEAR_MIPNEAREST_1: number;
    export { TEXTURE_NEAREST_LINEAR_MIPNEAREST_1 as TEXTURE_NEAREST_LINEAR_MIPNEAREST };
    const TEXTURE_NEAREST_LINEAR_MIPLINEAR_1: number;
    export { TEXTURE_NEAREST_LINEAR_MIPLINEAR_1 as TEXTURE_NEAREST_LINEAR_MIPLINEAR };
    const TEXTURE_NEAREST_LINEAR_1: number;
    export { TEXTURE_NEAREST_LINEAR_1 as TEXTURE_NEAREST_LINEAR };
    const TEXTURE_NEAREST_NEAREST_MIPLINEAR_1: number;
    export { TEXTURE_NEAREST_NEAREST_MIPLINEAR_1 as TEXTURE_NEAREST_NEAREST_MIPLINEAR };
    const TEXTURE_LINEAR_NEAREST_MIPNEAREST_1: number;
    export { TEXTURE_LINEAR_NEAREST_MIPNEAREST_1 as TEXTURE_LINEAR_NEAREST_MIPNEAREST };
    const TEXTURE_LINEAR_NEAREST_MIPLINEAR_1: number;
    export { TEXTURE_LINEAR_NEAREST_MIPLINEAR_1 as TEXTURE_LINEAR_NEAREST_MIPLINEAR };
    const TEXTURE_LINEAR_LINEAR_MIPNEAREST_1: number;
    export { TEXTURE_LINEAR_LINEAR_MIPNEAREST_1 as TEXTURE_LINEAR_LINEAR_MIPNEAREST };
    const TEXTURE_LINEAR_NEAREST_1: number;
    export { TEXTURE_LINEAR_NEAREST_1 as TEXTURE_LINEAR_NEAREST };
    const TEXTURE_EXPLICIT_MODE_1: number;
    export { TEXTURE_EXPLICIT_MODE_1 as TEXTURE_EXPLICIT_MODE };
    const TEXTURE_SPHERICAL_MODE_1: number;
    export { TEXTURE_SPHERICAL_MODE_1 as TEXTURE_SPHERICAL_MODE };
    const TEXTURE_PLANAR_MODE_1: number;
    export { TEXTURE_PLANAR_MODE_1 as TEXTURE_PLANAR_MODE };
    const TEXTURE_CUBIC_MODE_1: number;
    export { TEXTURE_CUBIC_MODE_1 as TEXTURE_CUBIC_MODE };
    const TEXTURE_PROJECTION_MODE_1: number;
    export { TEXTURE_PROJECTION_MODE_1 as TEXTURE_PROJECTION_MODE };
    const TEXTURE_SKYBOX_MODE_1: number;
    export { TEXTURE_SKYBOX_MODE_1 as TEXTURE_SKYBOX_MODE };
    const TEXTURE_INVCUBIC_MODE_1: number;
    export { TEXTURE_INVCUBIC_MODE_1 as TEXTURE_INVCUBIC_MODE };
    const TEXTURE_EQUIRECTANGULAR_MODE_1: number;
    export { TEXTURE_EQUIRECTANGULAR_MODE_1 as TEXTURE_EQUIRECTANGULAR_MODE };
    const TEXTURE_FIXED_EQUIRECTANGULAR_MODE_1: number;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MODE_1 as TEXTURE_FIXED_EQUIRECTANGULAR_MODE };
    const TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE_1: number;
    export { TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE_1 as TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE };
    export const TEXTURE_FILTERING_QUALITY_OFFLINE: number;
    export const TEXTURE_FILTERING_QUALITY_HIGH: number;
    export const TEXTURE_FILTERING_QUALITY_MEDIUM: number;
    export const TEXTURE_FILTERING_QUALITY_LOW: number;
    const SCALEMODE_FLOOR_1: number;
    export { SCALEMODE_FLOOR_1 as SCALEMODE_FLOOR };
    const SCALEMODE_NEAREST_1: number;
    export { SCALEMODE_NEAREST_1 as SCALEMODE_NEAREST };
    const SCALEMODE_CEILING_1: number;
    export { SCALEMODE_CEILING_1 as SCALEMODE_CEILING };
    export const MATERIAL_TextureDirtyFlag: number;
    export const MATERIAL_LightDirtyFlag: number;
    export const MATERIAL_FresnelDirtyFlag: number;
    export const MATERIAL_AttributesDirtyFlag: number;
    export const MATERIAL_MiscDirtyFlag: number;
    export const MATERIAL_PrePassDirtyFlag: number;
    export const MATERIAL_AllDirtyFlag: number;
    export const MATERIAL_TriangleFillMode: number;
    export const MATERIAL_WireFrameFillMode: number;
    export const MATERIAL_PointFillMode: number;
    export const MATERIAL_PointListDrawMode: number;
    export const MATERIAL_LineListDrawMode: number;
    export const MATERIAL_LineLoopDrawMode: number;
    export const MATERIAL_LineStripDrawMode: number;
    export const MATERIAL_TriangleStripDrawMode: number;
    export const MATERIAL_TriangleFanDrawMode: number;
    export const MATERIAL_ClockWiseSideOrientation: number;
    export const MATERIAL_CounterClockWiseSideOrientation: number;
    export const ACTION_NothingTrigger: number;
    export const ACTION_OnPickTrigger: number;
    export const ACTION_OnLeftPickTrigger: number;
    export const ACTION_OnRightPickTrigger: number;
    export const ACTION_OnCenterPickTrigger: number;
    export const ACTION_OnPickDownTrigger: number;
    export const ACTION_OnDoublePickTrigger: number;
    export const ACTION_OnPickUpTrigger: number;
    export const ACTION_OnPickOutTrigger: number;
    export const ACTION_OnLongPressTrigger: number;
    export const ACTION_OnPointerOverTrigger: number;
    export const ACTION_OnPointerOutTrigger: number;
    export const ACTION_OnEveryFrameTrigger: number;
    export const ACTION_OnIntersectionEnterTrigger: number;
    export const ACTION_OnIntersectionExitTrigger: number;
    export const ACTION_OnKeyDownTrigger: number;
    export const ACTION_OnKeyUpTrigger: number;
    export const PARTICLES_BILLBOARDMODE_Y: number;
    export const PARTICLES_BILLBOARDMODE_ALL: number;
    export const PARTICLES_BILLBOARDMODE_STRETCHED: number;
    export const MESHES_CULLINGSTRATEGY_STANDARD: number;
    export const MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY: number;
    export const MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION: number;
    export const MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY: number;
    export const SCENELOADER_NO_LOGGING: number;
    export const SCENELOADER_MINIMAL_LOGGING: number;
    export const SCENELOADER_SUMMARY_LOGGING: number;
    export const SCENELOADER_DETAILED_LOGGING: number;
    export const PREPASS_IRRADIANCE_TEXTURE_TYPE: number;
    export const PREPASS_POSITION_TEXTURE_TYPE: number;
    export const PREPASS_VELOCITY_TEXTURE_TYPE: number;
    export const PREPASS_REFLECTIVITY_TEXTURE_TYPE: number;
    export const PREPASS_COLOR_TEXTURE_TYPE: number;
    export const PREPASS_DEPTH_TEXTURE_TYPE: number;
    export const PREPASS_NORMAL_TEXTURE_TYPE: number;
    export const PREPASS_ALBEDO_SQRT_TEXTURE_TYPE: number;
    export const BUFFER_CREATIONFLAG_READ: number;
    export const BUFFER_CREATIONFLAG_WRITE: number;
    export const BUFFER_CREATIONFLAG_READWRITE: number;
    export const BUFFER_CREATIONFLAG_UNIFORM: number;
    export const BUFFER_CREATIONFLAG_VERTEX: number;
    export const BUFFER_CREATIONFLAG_INDEX: number;
    export const BUFFER_CREATIONFLAG_STORAGE: number;
    export const RENDERPASS_MAIN: number;
    export const INPUT_ALT_KEY: number;
    export const INPUT_CTRL_KEY: number;
    export const INPUT_META_KEY1: number;
    export const INPUT_META_KEY2: number;
    export const INPUT_META_KEY3: number;
    export const INPUT_SHIFT_KEY: number;
    export const SNAPSHOTRENDERING_STANDARD: number;
    export const SNAPSHOTRENDERING_FAST: number;
    export const PERSPECTIVE_CAMERA: number;
    export const ORTHOGRAPHIC_CAMERA: number;
    export const FOVMODE_VERTICAL_FIXED: number;
    export const FOVMODE_HORIZONTAL_FIXED: number;
    export const RIG_MODE_NONE: number;
    export const RIG_MODE_STEREOSCOPIC_ANAGLYPH: number;
    export const RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL: number;
    export const RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED: number;
    export const RIG_MODE_STEREOSCOPIC_OVERUNDER: number;
    export const RIG_MODE_STEREOSCOPIC_INTERLACED: number;
    export const RIG_MODE_VR: number;
    export const RIG_MODE_WEBVR: number;
    export const RIG_MODE_CUSTOM: number;
    export const MAX_SUPPORTED_UV_SETS: number;
    export const GL_ALPHA_EQUATION_ADD: number;
    export const GL_ALPHA_EQUATION_MIN: number;
    export const GL_ALPHA_EQUATION_MAX: number;
    export const GL_ALPHA_EQUATION_SUBTRACT: number;
    export const GL_ALPHA_EQUATION_REVERSE_SUBTRACT: number;
    export const GL_ALPHA_FUNCTION_SRC: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR: number;
    export const GL_ALPHA_FUNCTION_SRC_ALPHA: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA: number;
    export const GL_ALPHA_FUNCTION_DST_ALPHA: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA: number;
    export const GL_ALPHA_FUNCTION_DST_COLOR: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR: number;
    export const GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED: number;
    export const GL_ALPHA_FUNCTION_CONSTANT_COLOR: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR: number;
    export const GL_ALPHA_FUNCTION_CONSTANT_ALPHA: number;
    export const GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA: number;
}
declare class EventState {
    constructor(mask: any, skipNextObservers: boolean, target: any, currentTarget: any);
    initialize(mask: any, skipNextObservers: boolean, target: any, currentTarget: any): EventState;
    mask: any;
    skipNextObservers: boolean;
    target: any;
    currentTarget: any;
}
declare class Observer {
    constructor(callback: any, mask: any, scope?: any);
    callback: any;
    mask: any;
    scope: any;
    _willBeUnregistered: boolean;
    unregisterOnNextCall: boolean;
}
declare class WebGPUShaderProcessor {
    shaderLanguage: any;
    _addUniformToLeftOverUBO(name: any, uniformType: any, preProcessors: any): void;
    _buildLeftOverUBO(): any;
    _collectBindingNames(): void;
    _preCreateBindGroupEntries(): void;
    _addTextureBindingDescription(name: any, textureInfo: any, textureIndex: any, dimension: any, format: any, isVertex: any): void;
    _addSamplerBindingDescription(name: any, samplerInfo: any, isVertex: any): void;
    _addBufferBindingDescription(name: any, uniformBufferInfo: any, bufferType: any, isVertex: any): void;
    _injectStartingAndEndingCode(code: any, mainFuncDecl: any, startingCode: any, endingCode: any): any;
}
declare namespace WebGPUShaderProcessor {
    const AutoSamplerSuffix: string;
    const LeftOvertUBOName: string;
    const InternalsUBOName: string;
    namespace UniformSizes {
        const bool: number;
        const int: number;
        const float: number;
        const vec2: number;
        const ivec2: number;
        const vec3: number;
        const ivec3: number;
        const vec4: number;
        const ivec4: number;
        const mat2: number;
        const mat3: number;
        const mat4: number;
        const i32: number;
        const u32: number;
        const f32: number;
        const mat2x2: number;
        const mat3x3: number;
        const mat4x4: number;
    }
    namespace _SamplerFunctionByWebGLSamplerType {
        const sampler2D: string;
        const sampler2DArray: string;
        const sampler2DShadow: string;
        const sampler2DArrayShadow: string;
        const samplerCube: string;
        const sampler3D: string;
    }
    namespace _TextureTypeByWebGLSamplerType {
        const sampler2D_1: string;
        export { sampler2D_1 as sampler2D };
        const sampler2DArray_1: string;
        export { sampler2DArray_1 as sampler2DArray };
        const sampler2DShadow_1: string;
        export { sampler2DShadow_1 as sampler2DShadow };
        const sampler2DArrayShadow_1: string;
        export { sampler2DArrayShadow_1 as sampler2DArrayShadow };
        const samplerCube_1: string;
        export { samplerCube_1 as samplerCube };
        export const samplerCubeArray: string;
        const sampler3D_1: string;
        export { sampler3D_1 as sampler3D };
    }
    namespace _GpuTextureViewDimensionByWebGPUTextureType {
        const textureCube: any;
        const textureCubeArray: any;
        const texture2D: any;
        const texture2DArray: any;
        const texture3D: any;
    }
    namespace _SamplerTypeByWebGLSamplerType {
        const sampler2DShadow_2: string;
        export { sampler2DShadow_2 as sampler2DShadow };
        const sampler2DArrayShadow_2: string;
        export { sampler2DArrayShadow_2 as sampler2DArrayShadow };
    }
    namespace _IsComparisonSamplerByWebGPUSamplerType {
        const samplerShadow: boolean;
        const samplerArrayShadow: boolean;
        const sampler: boolean;
    }
}
declare class WebGPUBindGroupCacheNode {
    values: {};
}
declare class WebGPUDurationMeasure {
    constructor(device: any, bufferManager: any);
    _querySet: WebGPUQuerySet;
    start(encoder: any): void;
    stop(encoder: any): Promise<number>;
    dispose(): void;
}
declare class WebGPUQuerySet {
    constructor(count: any, type: any, device: any, bufferManager: any, canUseMultipleBuffers?: boolean);
    _dstBuffers: any[];
    _device: any;
    _bufferManager: any;
    _count: any;
    _canUseMultipleBuffers: boolean;
    _querySet: any;
    _queryBuffer: any;
    get querySet(): any;
    _getBuffer(firstQuery: any, queryCount: any): any;
    readValues(firstQuery?: number, queryCount?: number): Promise<BigUint64Array>;
    readValue(firstQuery?: number): Promise<number>;
    readTwoValuesAndSubtract(firstQuery?: number): Promise<number>;
    dispose(): void;
}
declare class DataBuffer {
    references: number;
    capacity: number;
    is32Bits: boolean;
    uniqueId: number;
    get underlyingResource(): any;
}
declare namespace DataBuffer {
    const _Counter_3: number;
    export { _Counter_3 as _Counter };
}
declare class Buffer {
    constructor(engine: any, data: any, updatable: any, stride: number, postponeInternalCreation: boolean, instanced: boolean, useBytes: boolean, divisor: any);
    _isAlreadyOwned: boolean;
    _engine: any;
    _updatable: any;
    _instanced: boolean;
    _divisor: any;
    _data: any;
    _buffer: DataBuffer;
    byteStride: number;
    createVertexBuffer(kind: any, offset: any, size: any, stride: any, instanced: any, useBytes: boolean, divisor: any): VertexBuffer;
    isUpdatable(): any;
    getData(): any;
    getBuffer(): DataBuffer;
    getStrideSize(): number;
    create(data?: any): void;
    _rebuild(): void;
    update(data: any): void;
    updateDirectly(data: any, offset: any, vertexCount: any, useBytes?: boolean): void;
    _increaseReferences(): void;
    dispose(): void;
}
declare class WebGPUCacheRenderPipeline {
    static _GetTopology(fillMode: any): any;
    static _GetAphaBlendOperation(operation: any): any;
    static _GetAphaBlendFactor(factor: any): any;
    static _GetCompareFunction(compareFunction: any): any;
    static _GetStencilOpFunction(operation: any): any;
    static _GetVertexInputDescriptorFormat(vertexBuffer: any): any;
    constructor(device: any, emptyVertexBuffer: any, useTextureStage: any);
    _device: any;
    _useTextureStage: any;
    _states: any[];
    _statesLength: number;
    _stateDirtyLowestIndex: number;
    _emptyVertexBuffer: any;
    _mrtFormats: any[];
    _parameter: {
        token: any;
        pipeline: any;
    };
    disabled: boolean;
    vertexBuffers: any[];
    _kMaxVertexBufferStride: any;
    reset(): void;
    _isDirty: any;
    _webgpuColorFormat: any[];
    get colorFormats(): any[];
    getRenderPipeline(fillMode: any, effect: any, sampleCount: any, textureState?: number): any;
    lastStateDirtyLowestIndex: number;
    endFrame(): void;
    setAlphaToCoverage(enabled: any): void;
    _alphaToCoverageEnabled: any;
    setFrontFace(frontFace: any): void;
    _frontFace: any;
    setCullEnabled(enabled: any): void;
    _cullEnabled: any;
    setCullFace(cullFace: any): void;
    _cullFace: any;
    setClampDepth(clampDepth: any): void;
    _clampDepth: any;
    resetDepthCullingState(): void;
    setDepthCullingState(cullEnabled: any, frontFace: any, cullFace: any, zOffset: any, zOffsetUnits: any, depthTestEnabled: any, depthWriteEnabled: any, depthCompare: any): void;
    _depthWriteEnabled: any;
    _depthTestEnabled: any;
    _depthCompare: number;
    setDepthBias(depthBias: any): void;
    _depthBias: any;
    setDepthBiasSlopeScale(depthBiasSlopeScale: any): void;
    _depthBiasSlopeScale: any;
    setColorFormat(format: any): void;
    _colorFormat: any;
    setMRTAttachments(attachments: any, textureArray: any): void;
    mrtAttachments: any;
    mrtTextureArray: any;
    _mrtAttachments1: any;
    _mrtAttachments2: number;
    setAlphaBlendEnabled(enabled: any): void;
    _alphaBlendEnabled: any;
    setAlphaBlendFactors(factors: any, operations: any): void;
    _alphaBlendFuncParams: any;
    _alphaBlendEqParams: any;
    setWriteMask(mask: any): void;
    _writeMask: any;
    setDepthStencilFormat(format: any): void;
    _webgpuDepthStencilFormat: any;
    _depthStencilFormat: any;
    setDepthTestEnabled(enabled: any): void;
    setDepthWriteEnabled(enabled: any): void;
    setDepthCompare(func: any): void;
    setStencilEnabled(enabled: any): void;
    _stencilEnabled: any;
    setStencilCompare(func: any): void;
    _stencilFrontCompare: number;
    setStencilDepthFailOp(op: any): void;
    _stencilFrontDepthFailOp: any;
    setStencilPassOp(op: any): void;
    _stencilFrontPassOp: any;
    setStencilFailOp(op: any): void;
    _stencilFrontFailOp: any;
    setStencilReadMask(mask: any): void;
    _stencilReadMask: any;
    setStencilWriteMask(mask: any): void;
    _stencilWriteMask: any;
    resetStencilState(): void;
    setStencilState(stencilEnabled: any, compare: any, depthFailOp: any, passOp: any, failOp: any, readMask: any, writeMask: any): void;
    setBuffers(vertexBuffers: any, indexBuffer: any, overrideVertexBuffers: any): void;
    _vertexBuffers: any;
    _overrideVertexBuffers: any;
    _indexBuffer: any;
    _getAphaBlendState(): {
        srcFactor: any;
        dstFactor: any;
        operation: any;
    };
    _getColorBlendState(): {
        srcFactor: any;
        dstFactor: any;
        operation: any;
    };
    _setShaderStage(id: any): void;
    _shaderId: any;
    _setRasterizationState(topology: any, sampleCount: any): void;
    _rasterizationState: any;
    _setColorStates(): void;
    _colorStates: any;
    _setDepthStencilState(): void;
    _depthStencilState: any;
    _setVertexState(effect: any): void;
    _setTextureState(textureState: any): void;
    _textureState: any;
    _createPipelineLayout(webgpuPipelineContext: any): any;
    _createPipelineLayoutWithTextureStage(webgpuPipelineContext: any): any;
    _getVertexInputDescriptor(effect: any, topology: any): {
        arrayStride: any;
        stepMode: any;
        attributes: any[];
    }[];
    _createRenderPipeline(effect: any, topology: any, sampleCount: any): any;
}
declare namespace WebGPUCacheRenderPipeline {
    const NumCacheHitWithoutHash: number;
    const NumCacheHitWithHash: number;
    const NumCacheMiss: number;
    const NumPipelineCreationLastFrame: number;
    const _NumPipelineCreationCurrentFrame: number;
}
declare class NodeState {
    values: {};
    count(): number[];
}
declare class DepthCullingState {
    constructor(reset?: boolean);
    _isDepthTestDirty: boolean;
    _isDepthMaskDirty: boolean;
    _isDepthFuncDirty: boolean;
    _isCullFaceDirty: boolean;
    _isCullDirty: boolean;
    _isZOffsetDirty: boolean;
    _isFrontFaceDirty: boolean;
    get isDirty(): boolean;
    set zOffset(arg: any);
    get zOffset(): any;
    _zOffset: any;
    set zOffsetUnits(arg: any);
    get zOffsetUnits(): any;
    _zOffsetUnits: any;
    set cullFace(arg: any);
    get cullFace(): any;
    _cullFace: any;
    set cull(arg: any);
    get cull(): any;
    _cull: any;
    set depthFunc(arg: any);
    get depthFunc(): any;
    _depthFunc: any;
    set depthMask(arg: any);
    get depthMask(): any;
    _depthMask: any;
    set depthTest(arg: any);
    get depthTest(): any;
    _depthTest: any;
    set frontFace(arg: any);
    get frontFace(): any;
    _frontFace: any;
    reset(): void;
    apply(gl: any): void;
}
declare class StencilStateComposer {
    constructor(reset?: boolean);
    _isStencilTestDirty: boolean;
    _isStencilMaskDirty: boolean;
    _isStencilFuncDirty: boolean;
    _isStencilOpDirty: boolean;
    useStencilGlobalOnly: boolean;
    get isDirty(): boolean;
    set func(arg: any);
    get func(): any;
    _func: any;
    set funcRef(arg: any);
    get funcRef(): any;
    _funcRef: any;
    set funcMask(arg: any);
    get funcMask(): any;
    _funcMask: any;
    set opStencilFail(arg: any);
    get opStencilFail(): any;
    _opStencilFail: any;
    set opDepthFail(arg: any);
    get opDepthFail(): any;
    _opDepthFail: any;
    set opStencilDepthPass(arg: any);
    get opStencilDepthPass(): any;
    _opStencilDepthPass: any;
    set mask(arg: any);
    get mask(): any;
    _mask: any;
    set enabled(arg: any);
    get enabled(): any;
    _enabled: any;
    reset(): void;
    stencilMaterial: any;
    apply(gl: any): void;
}
declare class StencilState {
    reset(): void;
    enabled: any;
    mask: any;
    func: any;
    funcRef: any;
    funcMask: any;
    opStencilFail: any;
    opDepthFail: any;
    opStencilDepthPass: any;
    set stencilFunc(arg: any);
    get stencilFunc(): any;
    set stencilFuncRef(arg: any);
    get stencilFuncRef(): any;
    set stencilFuncMask(arg: any);
    get stencilFuncMask(): any;
    set stencilOpStencilFail(arg: any);
    get stencilOpStencilFail(): any;
    set stencilOpDepthFail(arg: any);
    get stencilOpDepthFail(): any;
    set stencilOpStencilDepthPass(arg: any);
    get stencilOpStencilDepthPass(): any;
    set stencilMask(arg: any);
    get stencilMask(): any;
    set stencilTest(arg: any);
    get stencilTest(): any;
}
declare namespace StencilState {
    import ALWAYS_2 = Constants.ALWAYS;
    export { ALWAYS_2 as ALWAYS };
    import KEEP_2 = Constants.KEEP;
    export { KEEP_2 as KEEP };
    import REPLACE_2 = Constants.REPLACE;
    export { REPLACE_2 as REPLACE };
}
declare class AlphaState {
    _blendFunctionParameters: any[];
    _blendEquationParameters: any[];
    _blendConstants: any[];
    _isBlendConstantsDirty: boolean;
    _alphaBlend: boolean;
    _isAlphaBlendDirty: boolean;
    _isBlendFunctionParametersDirty: boolean;
    _isBlendEquationParametersDirty: boolean;
    get isDirty(): boolean;
    set alphaBlend(arg: boolean);
    get alphaBlend(): boolean;
    setAlphaBlendConstants(r: any, g: any, b: any, a: any): void;
    setAlphaBlendFunctionParameters(value0: any, value1: any, value2: any, value3: any): void;
    setAlphaEquationParameters(rgb: any, alpha: any): void;
    reset(): void;
    apply(gl: any): void;
}
declare class WebGLShaderProcessor {
    shaderLanguage: any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
}
declare class WebGL2ShaderProcessor {
    shaderLanguage: any;
    attributeProcessor(attribute: any): any;
    varyingProcessor(varying: any, isFragment: any): any;
    postProcessor(code: any, defines: any, isFragment: any, processingContext: any, engine: any): any;
}
declare class WebGLPipelineContext {
    _valueCache: {};
    vertexCompilationError: any;
    fragmentCompilationError: any;
    programLinkError: any;
    programValidationError: any;
    get isAsync(): any;
    get isReady(): any;
    _handlesSpectorRebuildCallback(onCompiled: any): void;
    _fillEffectInformation(effect: any, uniformBuffersNames: any, uniformsNames: any, uniforms: any, samplerList: any, samplers: any, attributesNames: any, attributes: any): void;
    _uniforms: any;
    dispose(): void;
    _cacheMatrix(uniformName: any, matrix: any): boolean;
    _cacheFloat2(uniformName: any, x: any, y: any): boolean;
    _cacheFloat3(uniformName: any, x: any, y: any, z: any): boolean;
    _cacheFloat4(uniformName: any, x: any, y: any, z: any, w: any): boolean;
    setInt(uniformName: any, value: any): void;
    setInt2(uniformName: any, x: any, y: any): void;
    setInt3(uniformName: any, x: any, y: any, z: any): void;
    setInt4(uniformName: any, x: any, y: any, z: any, w: any): void;
    setIntArray(uniformName: any, array: any): void;
    setIntArray2(uniformName: any, array: any): void;
    setIntArray3(uniformName: any, array: any): void;
    setIntArray4(uniformName: any, array: any): void;
    setArray(uniformName: any, array: any): void;
    setArray2(uniformName: any, array: any): void;
    setArray3(uniformName: any, array: any): void;
    setArray4(uniformName: any, array: any): void;
    setMatrices(uniformName: any, matrices: any): void;
    setMatrix(uniformName: any, matrix: any): void;
    setMatrix3x3(uniformName: any, matrix: any): void;
    setMatrix2x2(uniformName: any, matrix: any): void;
    setFloat(uniformName: any, value: any): void;
    setVector2(uniformName: any, vector2: any): void;
    setFloat2(uniformName: any, x: any, y: any): void;
    setVector3(uniformName: any, vector3: any): void;
    setFloat3(uniformName: any, x: any, y: any, z: any): void;
    setVector4(uniformName: any, vector4: any): void;
    setFloat4(uniformName: any, x: any, y: any, z: any, w: any): void;
    setColor3(uniformName: any, color3: any): void;
    setColor4(uniformName: any, color3: any, alpha: any): void;
    setDirectColor4(uniformName: any, color4: any): void;
    _getVertexShaderCode(): any;
    _getFragmentShaderCode(): any;
}
declare class WebGLHardwareTexture {
    constructor(existingTexture: any, context: any);
    _MSAARenderBuffer: any;
    _context: any;
    get underlyingResource(): any;
    setUsage(textureSource: any, generateMipMaps: any, isCube: any, width: any, height: any): void;
    set(hardwareTexture: any): void;
    _webGLTexture: any;
    reset(): void;
    release(): void;
}
declare class InternalTexture extends TextureSampler {
    constructor(engine: any, source: any, delayAllocation?: boolean);
    isReady: boolean;
    isCube: boolean;
    is3D: boolean;
    is2DArray: boolean;
    isMultiview: boolean;
    url: string;
    generateMipMaps: boolean;
    samples: number;
    type: number;
    format: number;
    onLoadedObservable: Observable;
    onErrorObservable: Observable;
    onRebuildCallback: any;
    width: number;
    height: number;
    depth: number;
    baseWidth: number;
    baseHeight: number;
    baseDepth: number;
    invertY: boolean;
    _invertVScale: boolean;
    _associatedChannel: number;
    _source: any;
    _buffer: any;
    _bufferView: any;
    _bufferViewArray: any;
    _bufferViewArrayArray: any;
    _size: number;
    _extension: string;
    _files: any;
    _workingCanvas: any;
    _workingContext: any;
    _cachedCoordinatesMode: any;
    _isDisabled: boolean;
    _compression: any;
    _sphericalPolynomial: any;
    _sphericalPolynomialPromise: any;
    _sphericalPolynomialComputed: boolean;
    _lodGenerationScale: number;
    _lodGenerationOffset: number;
    _useSRGBBuffer: boolean;
    _lodTextureHigh: any;
    _lodTextureMid: any;
    _lodTextureLow: any;
    _isRGBD: boolean;
    _linearSpecularLOD: boolean;
    _irradianceTexture: any;
    _hardwareTexture: any;
    _references: number;
    _gammaSpace: any;
    _engine: any;
    _uniqueId: number;
    get uniqueId(): number;
    getEngine(): any;
    get source(): any;
    incrementReferences(): void;
    updateSize(width: any, height: any, depth?: number): void;
    _rebuild(): void;
    _swapAndDie(target: any, swapAll?: boolean): void;
    dispose(): void;
}
declare namespace InternalTexture {
    const _Counter_4: number;
    export { _Counter_4 as _Counter };
}
declare class RollingAverage {
    constructor(length: any);
    _samples: any[];
    add(v: any): void;
    variance: number;
    history(i: any): any;
    isSaturated(): boolean;
    reset(): void;
    average: number;
    _sampleCount: number;
    _pos: number;
    _m2: number;
    _wrapPosition(i: any): number;
}
declare class TextureSampler {
    samplingMode: number;
    _useMipMaps: boolean;
    _cachedWrapU: any;
    _cachedWrapV: any;
    _cachedWrapR: any;
    _cachedAnisotropicFilteringLevel: any;
    _comparisonFunction: number;
    set wrapU(arg: any);
    get wrapU(): any;
    set wrapV(arg: any);
    get wrapV(): any;
    set wrapR(arg: any);
    get wrapR(): any;
    set anisotropicFilteringLevel(arg: any);
    get anisotropicFilteringLevel(): any;
    set comparisonFunction(arg: number);
    get comparisonFunction(): number;
    set useMipMaps(arg: boolean);
    get useMipMaps(): boolean;
    setParameters(wrapU?: number, wrapV?: number, wrapR?: number, anisotropicFilteringLevel?: number, samplingMode?: number, comparisonFunction?: number): TextureSampler;
    compareSampler(other: any): boolean;
}
export {};
